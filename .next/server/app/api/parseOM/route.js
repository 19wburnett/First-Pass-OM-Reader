"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/parseOM/route";
exports.ids = ["app/api/parseOM/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "pdf-parse":
/*!****************************!*\
  !*** external "pdf-parse" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("pdf-parse");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ "node:fs":
/*!**************************!*\
  !*** external "node:fs" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("node:fs");

/***/ }),

/***/ "node:stream":
/*!******************************!*\
  !*** external "node:stream" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("node:stream");

/***/ }),

/***/ "node:stream/web":
/*!**********************************!*\
  !*** external "node:stream/web" ***!
  \**********************************/
/***/ ((module) => {

module.exports = require("node:stream/web");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("punycode");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("stream");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ }),

/***/ "worker_threads":
/*!*********************************!*\
  !*** external "worker_threads" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("worker_threads");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("zlib");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2FparseOM%2Froute&page=%2Fapi%2FparseOM%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2FparseOM%2Froute.ts&appDir=C%3A%5CUsers%5Cwesto%5COneDrive%5CDocuments%5CFirst%20Pass%20OM%20Reader%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cwesto%5COneDrive%5CDocuments%5CFirst%20Pass%20OM%20Reader&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2FparseOM%2Froute&page=%2Fapi%2FparseOM%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2FparseOM%2Froute.ts&appDir=C%3A%5CUsers%5Cwesto%5COneDrive%5CDocuments%5CFirst%20Pass%20OM%20Reader%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cwesto%5COneDrive%5CDocuments%5CFirst%20Pass%20OM%20Reader&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   headerHooks: () => (/* binding */ headerHooks),\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage),\n/* harmony export */   staticGenerationBailout: () => (/* binding */ staticGenerationBailout)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var C_Users_westo_OneDrive_Documents_First_Pass_OM_Reader_app_api_parseOM_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/parseOM/route.ts */ \"(rsc)/./app/api/parseOM/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/parseOM/route\",\n        pathname: \"/api/parseOM\",\n        filename: \"route\",\n        bundlePath: \"app/api/parseOM/route\"\n    },\n    resolvedPagePath: \"C:\\\\Users\\\\westo\\\\OneDrive\\\\Documents\\\\First Pass OM Reader\\\\app\\\\api\\\\parseOM\\\\route.ts\",\n    nextConfigOutput,\n    userland: C_Users_westo_OneDrive_Documents_First_Pass_OM_Reader_app_api_parseOM_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks, headerHooks, staticGenerationBailout } = routeModule;\nconst originalPathname = \"/api/parseOM/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZwYXJzZU9NJTJGcm91dGUmcGFnZT0lMkZhcGklMkZwYXJzZU9NJTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGcGFyc2VPTSUyRnJvdXRlLnRzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUN3ZXN0byU1Q09uZURyaXZlJTVDRG9jdW1lbnRzJTVDRmlyc3QlMjBQYXNzJTIwT00lMjBSZWFkZXIlNUNhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPUMlM0ElNUNVc2VycyU1Q3dlc3RvJTVDT25lRHJpdmUlNUNEb2N1bWVudHMlNUNGaXJzdCUyMFBhc3MlMjBPTSUyMFJlYWRlciZpc0Rldj10cnVlJnRzY29uZmlnUGF0aD10c2NvbmZpZy5qc29uJmJhc2VQYXRoPSZhc3NldFByZWZpeD0mbmV4dENvbmZpZ091dHB1dD0mcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDYztBQUN3QztBQUNySDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0hBQW1CO0FBQzNDO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVHQUF1RztBQUMvRztBQUNBO0FBQ0EsV0FBVyw0RUFBVztBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQzZKOztBQUU3SiIsInNvdXJjZXMiOlsid2VicGFjazovL2NyZS11bmRlcndyaXRpbmctYXBwLz81ODA1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcFJvdXRlUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9hcHAtcm91dGUvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgcGF0Y2hGZXRjaCBhcyBfcGF0Y2hGZXRjaCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9wYXRjaC1mZXRjaFwiO1xuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIkM6XFxcXFVzZXJzXFxcXHdlc3RvXFxcXE9uZURyaXZlXFxcXERvY3VtZW50c1xcXFxGaXJzdCBQYXNzIE9NIFJlYWRlclxcXFxhcHBcXFxcYXBpXFxcXHBhcnNlT01cXFxccm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwiXCJcbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IEFwcFJvdXRlUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgcGFnZTogXCIvYXBpL3BhcnNlT00vcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9wYXJzZU9NXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9wYXJzZU9NL3JvdXRlXCJcbiAgICB9LFxuICAgIHJlc29sdmVkUGFnZVBhdGg6IFwiQzpcXFxcVXNlcnNcXFxcd2VzdG9cXFxcT25lRHJpdmVcXFxcRG9jdW1lbnRzXFxcXEZpcnN0IFBhc3MgT00gUmVhZGVyXFxcXGFwcFxcXFxhcGlcXFxccGFyc2VPTVxcXFxyb3V0ZS50c1wiLFxuICAgIG5leHRDb25maWdPdXRwdXQsXG4gICAgdXNlcmxhbmRcbn0pO1xuLy8gUHVsbCBvdXQgdGhlIGV4cG9ydHMgdGhhdCB3ZSBuZWVkIHRvIGV4cG9zZSBmcm9tIHRoZSBtb2R1bGUuIFRoaXMgc2hvdWxkXG4vLyBiZSBlbGltaW5hdGVkIHdoZW4gd2UndmUgbW92ZWQgdGhlIG90aGVyIHJvdXRlcyB0byB0aGUgbmV3IGZvcm1hdC4gVGhlc2Vcbi8vIGFyZSB1c2VkIHRvIGhvb2sgaW50byB0aGUgcm91dGUuXG5jb25zdCB7IHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBoZWFkZXJIb29rcywgc3RhdGljR2VuZXJhdGlvbkJhaWxvdXQgfSA9IHJvdXRlTW9kdWxlO1xuY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IFwiL2FwaS9wYXJzZU9NL3JvdXRlXCI7XG5mdW5jdGlvbiBwYXRjaEZldGNoKCkge1xuICAgIHJldHVybiBfcGF0Y2hGZXRjaCh7XG4gICAgICAgIHNlcnZlckhvb2tzLFxuICAgICAgICBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlXG4gICAgfSk7XG59XG5leHBvcnQgeyByb3V0ZU1vZHVsZSwgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIGhlYWRlckhvb2tzLCBzdGF0aWNHZW5lcmF0aW9uQmFpbG91dCwgb3JpZ2luYWxQYXRobmFtZSwgcGF0Y2hGZXRjaCwgIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2FparseOM%2Froute&page=%2Fapi%2FparseOM%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2FparseOM%2Froute.ts&appDir=C%3A%5CUsers%5Cwesto%5COneDrive%5CDocuments%5CFirst%20Pass%20OM%20Reader%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cwesto%5COneDrive%5CDocuments%5CFirst%20Pass%20OM%20Reader&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/parseOM/route.ts":
/*!**********************************!*\
  !*** ./app/api/parseOM/route.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/web/exports/next-response */ \"(rsc)/./node_modules/next/dist/server/web/exports/next-response.js\");\n/* harmony import */ var pdf_parse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pdf-parse */ \"pdf-parse\");\n/* harmony import */ var pdf_parse__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pdf_parse__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var openai__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! openai */ \"(rsc)/./node_modules/openai/index.mjs\");\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! xlsx */ \"(rsc)/./node_modules/xlsx/xlsx.mjs\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! papaparse */ \"(rsc)/./node_modules/papaparse/papaparse.js\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\n\n// Initialize OpenAI client\nconst openai = new openai__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({\n    apiKey: process.env.OPENAI_API_KEY\n});\nasync function parseRentRollFromUrl(url) {\n    try {\n        // Fetch file from Supabase URL\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`Failed to fetch rent roll file: ${response.statusText}`);\n        }\n        const arrayBuffer = await response.arrayBuffer();\n        const buffer = Buffer.from(arrayBuffer);\n        let data = [];\n        // Determine file type from URL extension\n        if (url.includes(\".csv\")) {\n            // Parse CSV\n            const csvText = buffer.toString(\"utf-8\");\n            const result = papaparse__WEBPACK_IMPORTED_MODULE_2___default().parse(csvText, {\n                header: true,\n                skipEmptyLines: true\n            });\n            data = result.data;\n        } else {\n            // Parse Excel\n            const workbook = xlsx__WEBPACK_IMPORTED_MODULE_4__.read(buffer, {\n                type: \"buffer\"\n            });\n            const sheetName = workbook.SheetNames[0];\n            const worksheet = workbook.Sheets[sheetName];\n            data = xlsx__WEBPACK_IMPORTED_MODULE_4__.utils.sheet_to_json(worksheet);\n        }\n        console.log(\"Raw rent roll data:\", data);\n        if (data.length === 0) {\n            throw new Error(\"No data found in rent roll file\");\n        }\n        // Process the data to extract rent roll information\n        let totalUnits = 0;\n        let occupiedUnits = 0;\n        let vacantUnits = 0;\n        let totalMonthlyRent = 0;\n        const units = [];\n        console.log(\"Processing rent roll rows:\", data.length);\n        // First, try to identify the structure by looking for summary rows\n        let summaryRow = null;\n        // Look for the actual totals row - check multiple possible formats\n        for (const row of data){\n            const rentRollCol = row[\"Rent Roll with Lease Charges\"];\n            if (rentRollCol && (rentRollCol === \"Totals:\" || rentRollCol === \"Total:\" || rentRollCol === \"TOTALS:\" || rentRollCol === \"TOTAL:\")) {\n                summaryRow = row;\n                console.log(\"Found totals row:\", row);\n                break;\n            }\n        }\n        // If we didn't find totals, look for the row with the highest unit count\n        if (!summaryRow) {\n            console.log(\"No totals row found, looking for row with highest unit count...\");\n            let maxUnits = 0;\n            for (const row of data){\n                const unitsStr = row[\"__EMPTY_9\"];\n                if (unitsStr && !isNaN(parseFloat(unitsStr))) {\n                    const units = parseInt(unitsStr);\n                    if (units > maxUnits && units > 100) {\n                        maxUnits = units;\n                        summaryRow = row;\n                    }\n                }\n            }\n            if (summaryRow) {\n                console.log(\"Found row with highest unit count:\", summaryRow);\n            }\n        }\n        // If still no summary row, look for any row with substantial units\n        if (!summaryRow) {\n            console.log(\"Still no summary row, looking for any substantial unit count...\");\n            for (const row of data){\n                const unitsStr = row[\"__EMPTY_9\"];\n                if (unitsStr && !isNaN(parseFloat(unitsStr))) {\n                    const units = parseInt(unitsStr);\n                    if (units > 200) {\n                        summaryRow = row;\n                        console.log(\"Found substantial unit count row:\", row);\n                        break;\n                    }\n                }\n            }\n        }\n        if (summaryRow) {\n            console.log(\"Found summary row:\", summaryRow);\n            // Extract totals from summary row - these are the actual property totals\n            const totalUnitsStr = summaryRow[\"__EMPTY_9\"] || summaryRow[\"# Of\"] || summaryRow[\"Units\"];\n            const totalRentStr = summaryRow[\"__EMPTY_4\"] || summaryRow[\"Market\"] || summaryRow[\"Rent\"] // Use __EMPTY_4 for monthly rent\n            ;\n            if (totalUnitsStr && !isNaN(parseFloat(totalUnitsStr))) {\n                totalUnits = parseInt(totalUnitsStr);\n                console.log(\"Extracted total units from summary:\", totalUnits);\n            }\n            if (totalRentStr && !isNaN(parseFloat(totalRentStr))) {\n                // __EMPTY_4 appears to be monthly rent, not annual\n                totalMonthlyRent = parseFloat(totalRentStr);\n                console.log(\"Extracted total monthly rent from summary:\", totalMonthlyRent);\n            }\n            // Look for occupancy information\n            const occupancyStr = summaryRow[\"__EMPTY_10\"] || summaryRow[\"% Unit\"] || summaryRow[\"Occupancy\"];\n            if (occupancyStr && !isNaN(parseFloat(occupancyStr))) {\n                const occupancyPercent = parseFloat(occupancyStr) / 100;\n                occupiedUnits = Math.round(totalUnits * occupancyPercent);\n                vacantUnits = totalUnits - occupiedUnits;\n                console.log(\"Extracted occupancy from summary:\", occupancyPercent, \"occupied:\", occupiedUnits, \"vacant:\", vacantUnits);\n            }\n        }\n        const occupancyRate = totalUnits > 0 ? occupiedUnits / totalUnits : 0;\n        const averageMonthlyRent = totalUnits > 0 ? totalMonthlyRent / totalUnits : 0;\n        const rentRollData = {\n            totalUnits,\n            occupiedUnits,\n            vacantUnits,\n            totalMonthlyRent,\n            averageMonthlyRent,\n            occupancyRate,\n            units\n        };\n        console.log(\"Processed rent roll data:\", rentRollData);\n        return rentRollData;\n    } catch (error) {\n        console.error(\"Error parsing rent roll:\", error);\n        throw new Error(`Failed to parse rent roll: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n}\n// Default underwriting assumptions\nconst DEFAULT_ASSUMPTIONS = {\n    vacancy: 0.05,\n    expenseRatio: 0.35,\n    marketCapRate: 0.06,\n    loanToValue: 0.65,\n    interestRate: 0.06,\n    amortizationYears: 30,\n    rentGrowthRate: 0.03,\n    expenseGrowthRate: 0.02,\n    exitCapRate: 0.065,\n    analysisTerm: 5 // 5-year analysis by default\n};\nasync function POST(request) {\n    try {\n        const body = await request.json();\n        const { omFileUrl, rentRollFileUrl, userAssumptions } = body;\n        if (!omFileUrl) {\n            return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                error: \"No OM file URL provided\"\n            }, {\n                status: 400\n            });\n        }\n        // Fetch PDF from Supabase URL\n        const pdfResponse = await fetch(omFileUrl);\n        if (!pdfResponse.ok) {\n            return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                error: \"Failed to fetch OM file from storage\"\n            }, {\n                status: 400\n            });\n        }\n        // Convert response to Buffer for pdf-parse\n        const pdfArrayBuffer = await pdfResponse.arrayBuffer();\n        const pdfBuffer = Buffer.from(pdfArrayBuffer);\n        // Extract text from PDF\n        const pdfData = await pdf_parse__WEBPACK_IMPORTED_MODULE_1___default()(pdfBuffer);\n        const extractedText = pdfData.text;\n        if (!extractedText || extractedText.trim().length === 0) {\n            return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                error: \"Could not extract text from PDF\"\n            }, {\n                status: 400\n            });\n        }\n        // Skip rent roll processing for now - focus on OM analysis only\n        let rentRollData;\n        console.log(\"Skipping rent roll processing - focusing on OM analysis only\");\n        // Send to OpenAI for analysis (rent roll data is now included in the response)\n        const parsedData = await analyzeWithOpenAI(extractedText, rentRollData);\n        console.log(\"Parsed data from OpenAI with rent roll:\", {\n            hasRentRollData: !!parsedData.rentRollData,\n            rentRollUnits: parsedData.rentRollData?.totalUnits,\n            rentRollMonthlyRent: parsedData.rentRollData?.totalMonthlyRent\n        });\n        // Merge user assumptions with defaults\n        const finalAssumptions = {\n            ...DEFAULT_ASSUMPTIONS,\n            ...userAssumptions && {\n                marketCapRate: userAssumptions.defaultCapRate,\n                exitCapRate: userAssumptions.exitCapRate,\n                loanToValue: userAssumptions.loanToValue,\n                interestRate: userAssumptions.interestRate,\n                analysisTerm: userAssumptions.analysisTerm\n            }\n        };\n        console.log(\"Using assumptions:\", {\n            default: DEFAULT_ASSUMPTIONS,\n            user: userAssumptions,\n            final: finalAssumptions\n        });\n        // Perform underwriting calculations\n        const dealData = performUnderwritingCalculations(parsedData, finalAssumptions);\n        return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json(dealData);\n    } catch (error) {\n        console.error(\"Error processing PDF:\", error);\n        return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n            error: \"Failed to process PDF\"\n        }, {\n            status: 500\n        });\n    }\n}\nasync function analyzeWithOpenAI(text, rentRollData) {\n    const prompt = `\nYou are a commercial real estate analyst. Focus on analyzing the Offering Memorandum text to extract comprehensive financial data.\n\nOM ANALYSIS:\nExtract the following information from the Offering Memorandum text and return ONLY a valid JSON object with these exact field names:\n\n{\n  \"propertyName\": \"string - name of the property\",\n  \"whisperPrice\": number - asking price or suggested price mentioned in the OM in USD (no commas or symbols). If no price is mentioned, use null,\n  \"units\": number - total number of units. Look for total units, apartments, or residential units mentioned in the OM,\n  \"occupancy\": number - occupancy rate as decimal (e.g., 0.95 for 95%). Look for occupancy rates mentioned in the OM,\n  \"avgRent\": number - average monthly rent per unit in USD. Look for 'average rent', 'monthly rent', 'rent per unit', or similar terms. If you see total annual income, divide by (units × 12) to get monthly rent per unit,\n  \"expenses\": number - annual operating expenses in USD. PRIORITY: Look for T-12 (Trailing 12 months) data, Proforma operating expenses, or annual expense figures. If not found, calculate as 35% of gross income.,\n  \"NOI\": number - Net Operating Income in USD. PRIORITY: Look for T-12 NOI, Proforma NOI, or actual NOI figures. If not found, calculate as gross income minus expenses.,\n  \"marketCapRate\": number - market cap rate as decimal (e.g., 0.06 for 6%)\n}\n\nCRITICAL: You MUST find and read the T-12 section in ORDER to understand the financial structure. Look for this exact sequence:\n\n1. \"T-12\" or \"Trailing 12 Months\" section (HIGHEST PRIORITY)\n2. Read the T-12 page from TOP to BOTTOM in this EXACT order:\n   - Look for \"GROSS POTENTIAL RENTAL INCOME\" (this is your gross income)\n   - Look for \"TOTAL OPERATING EXPENSES\" (this is your expenses)\n   - Look for \"NET OPERATING INCOME\" (this is your NOI)\n\n3. \"Income Statement\" or \"Financial Summary\" - for revenue/expense breakdown\n4. \"Operating Expenses\" or \"Expense Analysis\" - for cost details\n\nSPECIFICALLY LOOK FOR:\n- \"T-12\" sections (NOT \"YEAR 1\")\n- Read the T-12 page sequentially to understand the flow\n- Look for the actual numbers in the T-12 columns, not projections\n\nFOCUS ON THESE THREE KEY METRICS IN ORDER:\n1. \"GROSS POTENTIAL RENTAL INCOME\" - the total rental revenue\n2. \"TOTAL OPERATING EXPENSES\" - all operating costs\n3. \"NET OPERATING INCOME\" - the final NOI (gross income minus expenses)\n\nPRIORITY ORDER:\n1. FIRST: Use T-12 ACTUAL data (most accurate for current performance)\n2. SECOND: Use T-1 RENTAL INCOME data\n3. THIRD: Use any other current financial data found in the OM\n4. LAST: Only use YEAR 1 PROFORMA if no actual data exists\n\nREADING INSTRUCTIONS:\n- When you find the T-12 section, read it from TOP to BOTTOM\n- Look for the T-12 column (usually the leftmost column with actual numbers)\n- The T-12 column contains the ACTUAL current performance\n- The YEAR 1 column contains PROJECTIONS (ignore this for now)\n- Focus on reading the T-12 numbers in sequence to understand the financial flow\n\nThe T-12 ACTUAL data contains the most accurate current financial performance and should be your primary source for expenses, NOI, and rent projections.\n\nIf any information is missing, use reasonable estimates based on the property type and market. For missing values, use these defaults:\n- occupancy: 0.95 (95%)\n- marketCapRate: 0.06 (6%)\n- expenses: calculate as 35% of potential gross income if not provided\n- NOI: calculate as gross income minus expenses if not provided\n\nText to analyze:\n${text} // Full OM text for complete Proforma T-12 analysis\n`;\n    const completion = await openai.chat.completions.create({\n        model: \"gpt-4o\",\n        messages: [\n            {\n                role: \"system\",\n                content: \"You are a commercial real estate analyst who focuses on extracting comprehensive financial data from Offering Memorandums. You MUST return ONLY valid JSON with proper quotes around all property names and string values. Numbers should be unquoted. Do not include any explanatory text before or after the JSON.\"\n            },\n            {\n                role: \"user\",\n                content: prompt\n            }\n        ],\n        temperature: 0.1,\n        max_tokens: 500\n    });\n    const responseText = completion.choices[0]?.message?.content;\n    if (!responseText) {\n        throw new Error(\"No response from OpenAI\");\n    }\n    try {\n        // Extract JSON from response (handle cases where OpenAI adds extra text)\n        const jsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\n        if (!jsonMatch) {\n            throw new Error(\"No JSON found in OpenAI response\");\n        }\n        let jsonText = jsonMatch[0];\n        console.log(\"Extracted JSON text:\", jsonText);\n        // Try to clean up common JSON formatting issues\n        jsonText = jsonText.replace(/(\\w+):/g, '\"$1\":') // Add quotes around property names\n        .replace(/:\\s*([^\",\\{\\}\\[\\]]+)(?=\\s*[,}\\s])/g, ': \"$1\"') // Add quotes around string values\n        .replace(/:\\s*null(?=\\s*[,}\\s])/g, \": null\") // Keep null as null\n        .replace(/:\\s*(\\d+\\.?\\d*)(?=\\s*[,}\\s])/g, \": $1\") // Keep numbers as numbers\n        ;\n        console.log(\"Cleaned JSON text:\", jsonText);\n        let parsedData;\n        try {\n            parsedData = JSON.parse(jsonText);\n        } catch (cleanError) {\n            console.log(\"Failed to parse cleaned JSON, trying original:\", cleanError instanceof Error ? cleanError.message : \"Unknown error\");\n            // Fall back to original JSON parsing\n            parsedData = JSON.parse(jsonMatch[0]);\n        }\n        // Handle backward compatibility and field name variations\n        if (parsedData.purchasePrice !== undefined && parsedData.whisperPrice === undefined) {\n            console.log(\"AI returned purchasePrice, converting to whisperPrice for backward compatibility\");\n            parsedData.whisperPrice = parsedData.purchasePrice;\n            delete parsedData.purchasePrice;\n        }\n        // Handle other possible field name variations\n        if (parsedData.property_name !== undefined && !parsedData.propertyName) {\n            parsedData.propertyName = parsedData.property_name;\n            delete parsedData.property_name;\n        }\n        if (parsedData.avg_rent !== undefined && !parsedData.avgRent) {\n            parsedData.avgRent = parsedData.avg_rent;\n            delete parsedData.avg_rent;\n        }\n        if (parsedData.market_cap_rate !== undefined && !parsedData.marketCapRate) {\n            parsedData.marketCapRate = parsedData.market_cap_rate;\n            delete parsedData.market_cap_rate;\n        }\n        // Log the full response for debugging\n        console.log(\"Raw AI response:\", responseText);\n        console.log(\"Parsed data:\", parsedData);\n        // Validate required fields with detailed logging and provide defaults\n        const missingFields = [];\n        if (!parsedData.propertyName) missingFields.push(\"propertyName\");\n        if (!parsedData.units) missingFields.push(\"units\");\n        if (!parsedData.avgRent) missingFields.push(\"avgRent\");\n        if (missingFields.length > 0) {\n            console.error(\"Missing required fields:\", missingFields);\n            console.error(\"Available fields:\", Object.keys(parsedData));\n            console.error(\"Field values:\", parsedData);\n            // Provide reasonable defaults for missing fields\n            if (!parsedData.propertyName) parsedData.propertyName = \"Unknown Property\";\n            if (!parsedData.units) parsedData.units = 100 // Default to 100 units\n            ;\n            if (!parsedData.avgRent) parsedData.avgRent = 1500 // Default to $1,500/month\n            ;\n            console.log(\"Applied default values for missing fields:\", parsedData);\n        } else {\n            console.log(\"All required fields successfully extracted from OM\");\n        }\n        // Log the final values that will be used for calculations\n        const expectedGPI = parsedData.units * parsedData.avgRent * 12;\n        console.log(\"Final values for calculations:\", {\n            units: parsedData.units,\n            avgRent: parsedData.avgRent,\n            expectedGPI,\n            whisperPrice: parsedData.whisperPrice,\n            expenses: parsedData.expenses,\n            NOI: parsedData.NOI,\n            marketCapRate: parsedData.marketCapRate\n        });\n        // Validate that avgRent makes sense\n        if (parsedData.avgRent === 1500) {\n            console.warn(\"⚠️ WARNING: AI extracted default avgRent of $1,500. This might be wrong!\");\n            console.warn(\"If your OM shows different rent information, the AI failed to extract it correctly.\");\n        }\n        // Validate that the calculated GPI makes sense\n        if (expectedGPI > 1000000) {\n            console.warn(\"⚠️ WARNING: Calculated GPI seems very high. AI might have extracted wrong rent or units.\");\n        }\n        console.log(\"Successfully parsed AI response:\", parsedData);\n        // Include rent roll data in the returned data\n        const enhancedParsedData = {\n            ...parsedData,\n            rentRollData\n        };\n        console.log(\"Enhanced parsed data with rent roll:\", {\n            hasRentRollData: !!enhancedParsedData.rentRollData,\n            rentRollUnits: enhancedParsedData.rentRollData?.totalUnits,\n            rentRollMonthlyRent: enhancedParsedData.rentRollData?.totalMonthlyRent\n        });\n        return enhancedParsedData;\n    } catch (parseError) {\n        console.error(\"Failed to parse OpenAI response:\", responseText);\n        console.error(\"Parse error:\", parseError);\n        // Try to extract any useful information from the response\n        if (responseText.includes(\"property\") || responseText.includes(\"rent\") || responseText.includes(\"units\")) {\n            console.log(\"Response contains some property information, attempting to extract...\");\n        // You could add more sophisticated parsing here if needed\n        }\n        throw new Error(`Failed to parse AI analysis: ${parseError instanceof Error ? parseError.message : \"Unknown error\"}`);\n    }\n}\nfunction performUnderwritingCalculations(parsedData, assumptions) {\n    const { whisperPrice, units, occupancy, avgRent, expenses: parsedExpenses, NOI: parsedNOI, marketCapRate, rentRollData } = parsedData;\n    // Use rent roll data if available, otherwise use OM data\n    const finalUnits = rentRollData ? rentRollData.totalUnits : units;\n    const finalOccupancy = rentRollData ? rentRollData.occupancyRate : occupancy;\n    const finalAvgRent = rentRollData ? rentRollData.averageMonthlyRent : avgRent;\n    console.log(\"Final values for calculations:\", {\n        rentRollData: !!rentRollData,\n        rentRollDataDetails: rentRollData ? {\n            totalUnits: rentRollData.totalUnits,\n            totalMonthlyRent: rentRollData.totalMonthlyRent,\n            occupancyRate: rentRollData.occupancyRate\n        } : null,\n        finalUnits,\n        finalOccupancy,\n        finalAvgRent,\n        originalUnits: units,\n        originalOccupancy: occupancy,\n        originalAvgRent: avgRent\n    });\n    // Calculate pro forma metrics\n    console.log(\"Pro forma calculation inputs:\", {\n        finalUnits,\n        finalAvgRent,\n        finalOccupancy,\n        parsedExpenses,\n        parsedNOI,\n        marketCapRate\n    });\n    const grossPotentialIncome = finalUnits * finalAvgRent * 12;\n    const vacancy = finalOccupancy // Use actual occupancy from rent roll if available\n    ;\n    const effectiveGrossIncome = grossPotentialIncome * (1 - vacancy);\n    // If we have rent roll data, calculate NOI from scratch\n    let finalNOI = parsedNOI;\n    if (rentRollData && rentRollData.totalUnits > 0) {\n        // Calculate NOI based on rent roll data\n        const annualRent = rentRollData.totalMonthlyRent * 12;\n        const vacancyLoss = annualRent * (1 - rentRollData.occupancyRate);\n        const effectiveGrossIncome = annualRent - vacancyLoss;\n        const operatingExpenses = effectiveGrossIncome * assumptions.expenseRatio;\n        finalNOI = effectiveGrossIncome - operatingExpenses;\n        console.log(\"Calculated NOI from rent roll:\", {\n            annualRent,\n            vacancyLoss,\n            effectiveGrossIncome,\n            operatingExpenses,\n            finalNOI\n        });\n    }\n    // Ensure we have a valid NOI\n    if (!finalNOI || finalNOI <= 0) {\n        console.log(\"⚠️ WARNING: Invalid NOI detected, using fallback calculation\");\n        finalNOI = effectiveGrossIncome * (1 - assumptions.expenseRatio);\n        console.log(\"Fallback NOI calculated:\", finalNOI);\n    }\n    console.log(\"Pro forma calculations:\", {\n        grossPotentialIncome,\n        vacancy,\n        effectiveGrossIncome\n    });\n    // Use parsed expenses or calculate based on assumption\n    const operatingExpenses = parsedExpenses || effectiveGrossIncome * assumptions.expenseRatio;\n    // Use the calculated finalNOI (from rent roll if available) instead of parsed NOI\n    const NOI = finalNOI;\n    // Calculate purchase price using cap rate and NOI (this is the \"market value\")\n    const purchasePrice = NOI / assumptions.marketCapRate;\n    // Calculate price difference (whisper price - calculated price)\n    const priceDifference = whisperPrice && whisperPrice > 0 ? whisperPrice - purchasePrice : 0;\n    // Cap rate valuation (same as purchase price)\n    const capRateValuation = purchasePrice;\n    console.log(\"Pricing calculations:\", {\n        whisperPrice,\n        originalParsedNOI: parsedNOI,\n        calculatedFinalNOI: finalNOI,\n        finalNOIUsed: NOI,\n        marketCapRate: assumptions.marketCapRate,\n        calculatedPurchasePrice: purchasePrice,\n        priceDifference\n    });\n    // Financing calculations\n    const loanAmount = purchasePrice * assumptions.loanToValue;\n    const equity = purchasePrice - loanAmount;\n    // Calculate monthly payment for 30-year fixed loan\n    const monthlyRate = assumptions.interestRate / 12;\n    const totalPayments = assumptions.amortizationYears * 12;\n    const debtService = loanAmount * (monthlyRate * Math.pow(1 + monthlyRate, totalPayments)) / (Math.pow(1 + monthlyRate, totalPayments) - 1);\n    const annualDebtService = debtService * 12;\n    // Investment metrics\n    const DSCR = NOI / annualDebtService;\n    const cashOnCashReturn = (NOI - annualDebtService) / equity;\n    // Dynamic-term IRR calculation (detailed, Excel-like)\n    const { leveredIRR, unleveredIRR, irrBreakdown } = calculateDetailedIRR(purchasePrice, equity, loanAmount, NOI, annualDebtService, assumptions, rentRollData // Pass rent roll data for accurate calculations\n    );\n    // Log the IRR calculation for debugging\n    console.log(\"IRR Calculation Breakdown:\");\n    irrBreakdown.forEach((row)=>{\n        console.log(`Year ${row.year}:`, {\n            NOI: row.NOI,\n            debtService: row.debtService,\n            cashFlowBeforeDebt: row.cashFlowBeforeDebt,\n            cashFlowAfterDebt: row.cashFlowAfterDebt,\n            cumulativeCashFlowBeforeDebt: row.cumulativeCashFlowBeforeDebt,\n            cumulativeCashFlowAfterDebt: row.cumulativeCashFlowAfterDebt,\n            remainingDebt: row.remainingDebt,\n            propertyValue: row.propertyValue,\n            exitEquity: row.exitEquity\n        });\n    });\n    console.log(\"Final IRRs - Levered:\", leveredIRR, \"Unlevered:\", unleveredIRR);\n    const finalDealData = {\n        ...parsedData,\n        units: finalUnits,\n        occupancy: finalOccupancy,\n        avgRent: finalAvgRent,\n        NOI: finalNOI,\n        purchasePrice,\n        priceDifference,\n        grossPotentialIncome,\n        effectiveGrossIncome,\n        operatingExpenses,\n        capRateValuation,\n        debtService: annualDebtService,\n        DSCR,\n        cashOnCashReturn,\n        leveredIRR,\n        unleveredIRR,\n        equity,\n        loanAmount,\n        vacancy,\n        expenseRatio: assumptions.expenseRatio,\n        marketCapRate: assumptions.marketCapRate,\n        irrBreakdown,\n        rentRollData\n    };\n    console.log(\"Final deal data being returned:\", {\n        units: finalDealData.units,\n        occupancy: finalDealData.occupancy,\n        avgRent: finalDealData.avgRent,\n        NOI: finalDealData.NOI,\n        rentRollData: !!finalDealData.rentRollData\n    });\n    return finalDealData;\n}\nfunction calculateDetailedIRR(purchasePrice, equity, loanAmount, initialNOI, initialDebtService, assumptions, rentRollData) {\n    console.log(\"IRR calculation inputs:\", {\n        purchasePrice,\n        equity,\n        loanAmount,\n        initialNOI,\n        initialDebtService,\n        assumptions\n    });\n    const breakdown = [];\n    let remainingDebt = loanAmount;\n    // Year 0: Initial investment\n    breakdown.push({\n        year: 0,\n        grossIncome: 0,\n        operatingExpenses: 0,\n        NOI: 0,\n        debtService: 0,\n        cashFlowBeforeDebt: 0,\n        cashFlowAfterDebt: -equity,\n        cumulativeCashFlowBeforeDebt: 0,\n        cumulativeCashFlowAfterDebt: -equity,\n        remainingDebt: loanAmount,\n        propertyValue: purchasePrice,\n        exitEquity: 0,\n        totalReturnUnlevered: 0,\n        totalReturnLevered: -equity,\n        annualCashOnCash: 0\n    });\n    // Years 1 to analysisTerm: Operating period\n    for(let year = 1; year <= assumptions.analysisTerm; year++){\n        // Calculate growing income and expenses\n        const rentGrowth = Math.pow(1 + assumptions.rentGrowthRate, year);\n        const expenseGrowth = Math.pow(1 + assumptions.expenseGrowthRate, year);\n        // Use rent roll data if available for accurate gross income\n        let yearGrossIncome;\n        let yearOperatingExpenses;\n        let yearNOI;\n        if (rentRollData && rentRollData.totalUnits > 0) {\n            // Calculate from actual rent roll data\n            const baseAnnualRent = rentRollData.totalMonthlyRent * 12;\n            yearGrossIncome = baseAnnualRent * rentGrowth;\n            yearOperatingExpenses = yearGrossIncome * assumptions.expenseRatio;\n            yearNOI = yearGrossIncome - yearOperatingExpenses;\n        } else {\n            // Fallback to NOI-based calculation\n            yearNOI = initialNOI * rentGrowth;\n            yearGrossIncome = yearNOI / (1 - assumptions.expenseRatio);\n            yearOperatingExpenses = yearGrossIncome - yearNOI;\n        }\n        console.log(`Year ${year} calculations:`, {\n            rentGrowth: rentGrowth.toFixed(4),\n            yearNOI: yearNOI.toFixed(2),\n            yearGrossIncome: yearGrossIncome.toFixed(2),\n            yearOperatingExpenses: yearOperatingExpenses.toFixed(2)\n        });\n        // Debt service remains constant (fixed-rate loan)\n        const yearDebtService = initialDebtService;\n        // Calculate remaining debt (simplified - assumes linear amortization)\n        const annualPrincipal = loanAmount / assumptions.amortizationYears;\n        remainingDebt = Math.max(0, remainingDebt - annualPrincipal);\n        // Cash flows before and after debt\n        const yearCashFlowBeforeDebt = yearNOI;\n        const yearCashFlowAfterDebt = yearNOI - yearDebtService;\n        // Cumulative cash flows\n        const cumulativeCashFlowBeforeDebt = breakdown[year - 1].cumulativeCashFlowBeforeDebt + yearCashFlowBeforeDebt;\n        const cumulativeCashFlowAfterDebt = breakdown[year - 1].cumulativeCashFlowAfterDebt + yearCashFlowAfterDebt;\n        // Property value growth (using cap rate)\n        const yearPropertyValue = year === assumptions.analysisTerm ? yearNOI / assumptions.exitCapRate : yearNOI / assumptions.marketCapRate // Use market cap rate for intermediate years\n        ;\n        // Exit equity (what you'd get if you sold)\n        const exitEquity = year === assumptions.analysisTerm ? yearPropertyValue - remainingDebt : 0;\n        // Total return to date (not used in new structure)\n        // const totalReturn = cumulativeCashFlow + exitEquity\n        // Calculate annual cash-on-cash return (Year 1-5 only, not Year 0)\n        const annualCashOnCash = year === 0 ? 0 : yearCashFlowAfterDebt / equity;\n        breakdown.push({\n            year,\n            grossIncome: yearGrossIncome,\n            operatingExpenses: yearOperatingExpenses,\n            NOI: yearNOI,\n            debtService: yearDebtService,\n            cashFlowBeforeDebt: yearCashFlowBeforeDebt,\n            cashFlowAfterDebt: yearCashFlowAfterDebt,\n            cumulativeCashFlowBeforeDebt,\n            cumulativeCashFlowAfterDebt,\n            remainingDebt,\n            propertyValue: yearPropertyValue,\n            exitEquity,\n            totalReturnUnlevered: cumulativeCashFlowBeforeDebt + exitEquity,\n            totalReturnLevered: cumulativeCashFlowAfterDebt + exitEquity,\n            annualCashOnCash\n        });\n    }\n    // Calculate Levered IRR (with debt) - cash flows after debt service\n    const leveredCashFlows = breakdown.map((row)=>row.cashFlowAfterDebt);\n    leveredCashFlows[0] = -equity // Initial equity investment (negative)\n    ;\n    leveredCashFlows[assumptions.analysisTerm] += breakdown[assumptions.analysisTerm].propertyValue - breakdown[assumptions.analysisTerm].remainingDebt // Add net sale proceeds to final year\n    ;\n    console.log(\"Levered cash flows for IRR calculation:\", leveredCashFlows);\n    let leveredIRR = calculateIRR(leveredCashFlows);\n    // Validate levered IRR is reasonable (between -50% and +200%)\n    if (leveredIRR < -0.5 || leveredIRR > 2.0) {\n        console.log(\"Levered IRR out of reasonable range, using fallback\");\n        leveredIRR = calculateSimpleIRR(leveredCashFlows, equity, assumptions.analysisTerm);\n    }\n    // Calculate Unlevered IRR (no debt) - cash flows before debt service\n    const unleveredCashFlows = breakdown.map((row)=>row.cashFlowBeforeDebt);\n    unleveredCashFlows[0] = -purchasePrice // Initial property investment (negative)\n    ;\n    unleveredCashFlows[assumptions.analysisTerm] += breakdown[assumptions.analysisTerm].propertyValue // Add full property sale value to final year\n    ;\n    console.log(\"Unlevered cash flows for IRR calculation:\", unleveredCashFlows);\n    let unleveredIRR = calculateIRR(unleveredCashFlows);\n    // Validate unlevered IRR is reasonable (between -50% and +200%)\n    if (unleveredIRR < -0.5 || unleveredIRR > 2.0) {\n        console.log(\"Unlevered IRR out of reasonable range, using fallback\");\n        unleveredIRR = calculateSimpleIRR(unleveredCashFlows, purchasePrice, assumptions.analysisTerm);\n    }\n    console.log(\"Final validated IRRs - Levered:\", leveredIRR, \"Unlevered:\", unleveredIRR);\n    return {\n        leveredIRR,\n        unleveredIRR,\n        irrBreakdown: breakdown\n    };\n}\nfunction calculateIRR(cashFlows) {\n    // Newton-Raphson method for IRR calculation\n    let guess = 0.15 // Start with 15% guess\n    ;\n    const tolerance = 0.0001;\n    const maxIterations = 100;\n    console.log(\"Starting IRR calculation with cash flows:\", cashFlows);\n    console.log(\"Initial guess:\", guess);\n    for(let i = 0; i < maxIterations; i++){\n        const npv = calculateNPV(cashFlows, guess);\n        const derivative = calculateNPVDerivative(cashFlows, guess);\n        console.log(`Iteration ${i + 1}: guess=${guess.toFixed(6)}, npv=${npv.toFixed(2)}, derivative=${derivative.toFixed(6)}`);\n        if (Math.abs(derivative) < 0.0001) {\n            console.log(\"Derivative too small, breaking\");\n            break;\n        }\n        const newGuess = guess - npv / derivative;\n        // Prevent extreme values\n        if (newGuess < -0.99 || newGuess > 10) {\n            console.log(\"Guess out of reasonable range, using fallback\");\n            return 0.15 // Fallback to 15%\n            ;\n        }\n        if (Math.abs(newGuess - guess) < tolerance) {\n            console.log(\"Converged to IRR:\", newGuess);\n            return newGuess;\n        }\n        guess = newGuess;\n    }\n    console.log(\"Max iterations reached, returning guess:\", guess);\n    return guess;\n}\nfunction calculateNPV(cashFlows, rate) {\n    let npv = 0;\n    for(let i = 0; i < cashFlows.length; i++){\n        npv += cashFlows[i] / Math.pow(1 + rate, i);\n    }\n    return npv;\n}\nfunction calculateNPVDerivative(cashFlows, rate) {\n    let derivative = 0;\n    for(let i = 1; i < cashFlows.length; i++){\n        derivative -= i * cashFlows[i] / Math.pow(1 + rate, i + 1);\n    }\n    return derivative;\n}\nfunction calculateSimpleIRR(cashFlows, equity, analysisTerm = 5) {\n    // Simple IRR approximation based on total return\n    const totalCashFlow = cashFlows.reduce((sum, cf)=>sum + cf, 0);\n    const totalReturn = totalCashFlow + equity;\n    if (totalReturn <= 0) {\n        return 0.05 // 5% if no positive return\n        ;\n    }\n    // Simple approximation: assume average return over analysis term\n    const avgAnnualReturn = totalReturn / analysisTerm;\n    const simpleIRR = avgAnnualReturn / equity;\n    // Cap at reasonable levels\n    return Math.min(Math.max(simpleIRR, 0.05), 0.30);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUlzRCxNQUFNUCxJQUFJO0lBQzVEO0lBQ0EsT0FBT0c7QUFDVDtBQUVBLFNBQVNULG1CQUFtQkUsU0FBbUIsRUFBRS9DLE1BQWMsRUFBRXpGLGVBQXVCLENBQUM7SUFDdkYsaURBQWlEO0lBQ2pELE1BQU1vSixnQkFBZ0JaLFVBQVVhLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxLQUFPRCxNQUFNQyxJQUFJO0lBQzlELE1BQU1DLGNBQWNKLGdCQUFnQjNEO0lBRXBDLElBQUkrRCxlQUFlLEdBQUc7UUFDcEIsT0FBTyxLQUFLLDJCQUEyQjs7SUFDekM7SUFFQSxpRUFBaUU7SUFDakUsTUFBTUMsa0JBQWtCRCxjQUFjeEo7SUFDdEMsTUFBTTBKLFlBQVlELGtCQUFrQmhFO0lBRXBDLDJCQUEyQjtJQUMzQixPQUFPMUcsS0FBSzRLLEdBQUcsQ0FBQzVLLEtBQUtnSixHQUFHLENBQUMyQixXQUFXLE9BQU87QUFDN0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmUtdW5kZXJ3cml0aW5nLWFwcC8uL2FwcC9hcGkvcGFyc2VPTS9yb3V0ZS50cz9mN2ZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRSZXF1ZXN0LCBOZXh0UmVzcG9uc2UgfSBmcm9tICduZXh0L3NlcnZlcidcbmltcG9ydCBwZGYgZnJvbSAncGRmLXBhcnNlJ1xuaW1wb3J0IE9wZW5BSSBmcm9tICdvcGVuYWknXG5pbXBvcnQgKiBhcyBYTFNYIGZyb20gJ3hsc3gnXG5pbXBvcnQgUGFwYSBmcm9tICdwYXBhcGFyc2UnXG5pbXBvcnQgeyBQYXJzZWRPTURhdGEsIERlYWxEYXRhLCBVbmRlcndyaXRpbmdBc3N1bXB0aW9ucywgSVJSQnJlYWtkb3duLCBSZW50Um9sbERhdGEsIFVzZXJBc3N1bXB0aW9ucyB9IGZyb20gJy4uLy4uL3R5cGVzJ1xuXG4vLyBJbml0aWFsaXplIE9wZW5BSSBjbGllbnRcbmNvbnN0IG9wZW5haSA9IG5ldyBPcGVuQUkoe1xuICBhcGlLZXk6IHByb2Nlc3MuZW52Lk9QRU5BSV9BUElfS0VZLFxufSlcblxuYXN5bmMgZnVuY3Rpb24gcGFyc2VSZW50Um9sbEZyb21VcmwodXJsOiBzdHJpbmcpOiBQcm9taXNlPFJlbnRSb2xsRGF0YT4ge1xuICB0cnkge1xuICAgIC8vIEZldGNoIGZpbGUgZnJvbSBTdXBhYmFzZSBVUkxcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybClcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCByZW50IHJvbGwgZmlsZTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKVxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyKVxuICAgIFxuICAgIGxldCBkYXRhOiBhbnlbXSA9IFtdXG4gICAgXG4gICAgLy8gRGV0ZXJtaW5lIGZpbGUgdHlwZSBmcm9tIFVSTCBleHRlbnNpb25cbiAgICBpZiAodXJsLmluY2x1ZGVzKCcuY3N2JykpIHtcbiAgICAgIC8vIFBhcnNlIENTVlxuICAgICAgY29uc3QgY3N2VGV4dCA9IGJ1ZmZlci50b1N0cmluZygndXRmLTgnKVxuICAgICAgY29uc3QgcmVzdWx0ID0gUGFwYS5wYXJzZShjc3ZUZXh0LCB7IGhlYWRlcjogdHJ1ZSwgc2tpcEVtcHR5TGluZXM6IHRydWUgfSlcbiAgICAgIGRhdGEgPSByZXN1bHQuZGF0YVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQYXJzZSBFeGNlbFxuICAgICAgY29uc3Qgd29ya2Jvb2sgPSBYTFNYLnJlYWQoYnVmZmVyLCB7IHR5cGU6ICdidWZmZXInIH0pXG4gICAgICBjb25zdCBzaGVldE5hbWUgPSB3b3JrYm9vay5TaGVldE5hbWVzWzBdXG4gICAgICBjb25zdCB3b3Jrc2hlZXQgPSB3b3JrYm9vay5TaGVldHNbc2hlZXROYW1lXVxuICAgICAgZGF0YSA9IFhMU1gudXRpbHMuc2hlZXRfdG9fanNvbih3b3Jrc2hlZXQpXG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdSYXcgcmVudCByb2xsIGRhdGE6JywgZGF0YSlcbiAgICBcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF0YSBmb3VuZCBpbiByZW50IHJvbGwgZmlsZScpXG4gICAgfVxuICAgIFxuICAgIC8vIFByb2Nlc3MgdGhlIGRhdGEgdG8gZXh0cmFjdCByZW50IHJvbGwgaW5mb3JtYXRpb25cbiAgICBsZXQgdG90YWxVbml0cyA9IDBcbiAgICBsZXQgb2NjdXBpZWRVbml0cyA9IDBcbiAgICBsZXQgdmFjYW50VW5pdHMgPSAwXG4gICAgbGV0IHRvdGFsTW9udGhseVJlbnQgPSAwXG4gICAgY29uc3QgdW5pdHM6IGFueVtdID0gW11cbiAgICBcbiAgICBjb25zb2xlLmxvZygnUHJvY2Vzc2luZyByZW50IHJvbGwgcm93czonLCBkYXRhLmxlbmd0aClcbiAgICBcbiAgICAvLyBGaXJzdCwgdHJ5IHRvIGlkZW50aWZ5IHRoZSBzdHJ1Y3R1cmUgYnkgbG9va2luZyBmb3Igc3VtbWFyeSByb3dzXG4gICAgbGV0IHN1bW1hcnlSb3cgPSBudWxsXG4gICAgXG4gICAgLy8gTG9vayBmb3IgdGhlIGFjdHVhbCB0b3RhbHMgcm93IC0gY2hlY2sgbXVsdGlwbGUgcG9zc2libGUgZm9ybWF0c1xuICAgIGZvciAoY29uc3Qgcm93IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IHJlbnRSb2xsQ29sID0gcm93WydSZW50IFJvbGwgd2l0aCBMZWFzZSBDaGFyZ2VzJ11cbiAgICAgIGlmIChyZW50Um9sbENvbCAmJiAoXG4gICAgICAgICAgcmVudFJvbGxDb2wgPT09ICdUb3RhbHM6JyB8fCBcbiAgICAgICAgICByZW50Um9sbENvbCA9PT0gJ1RvdGFsOicgfHxcbiAgICAgICAgICByZW50Um9sbENvbCA9PT0gJ1RPVEFMUzonIHx8XG4gICAgICAgICAgcmVudFJvbGxDb2wgPT09ICdUT1RBTDonXG4gICAgICApKSB7XG4gICAgICAgIHN1bW1hcnlSb3cgPSByb3dcbiAgICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIHRvdGFscyByb3c6Jywgcm93KVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluZCB0b3RhbHMsIGxvb2sgZm9yIHRoZSByb3cgd2l0aCB0aGUgaGlnaGVzdCB1bml0IGNvdW50XG4gICAgaWYgKCFzdW1tYXJ5Um93KSB7XG4gICAgICBjb25zb2xlLmxvZygnTm8gdG90YWxzIHJvdyBmb3VuZCwgbG9va2luZyBmb3Igcm93IHdpdGggaGlnaGVzdCB1bml0IGNvdW50Li4uJylcbiAgICAgIGxldCBtYXhVbml0cyA9IDBcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIGRhdGEpIHtcbiAgICAgICAgY29uc3QgdW5pdHNTdHIgPSByb3dbJ19fRU1QVFlfOSddXG4gICAgICAgIGlmICh1bml0c1N0ciAmJiAhaXNOYU4ocGFyc2VGbG9hdCh1bml0c1N0cikpKSB7XG4gICAgICAgICAgY29uc3QgdW5pdHMgPSBwYXJzZUludCh1bml0c1N0cilcbiAgICAgICAgICBpZiAodW5pdHMgPiBtYXhVbml0cyAmJiB1bml0cyA+IDEwMCkgeyAvLyBNdXN0IGJlIGEgcmVhc29uYWJsZSBudW1iZXJcbiAgICAgICAgICAgIG1heFVuaXRzID0gdW5pdHNcbiAgICAgICAgICAgIHN1bW1hcnlSb3cgPSByb3dcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdW1tYXJ5Um93KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCByb3cgd2l0aCBoaWdoZXN0IHVuaXQgY291bnQ6Jywgc3VtbWFyeVJvdylcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSWYgc3RpbGwgbm8gc3VtbWFyeSByb3csIGxvb2sgZm9yIGFueSByb3cgd2l0aCBzdWJzdGFudGlhbCB1bml0c1xuICAgIGlmICghc3VtbWFyeVJvdykge1xuICAgICAgY29uc29sZS5sb2coJ1N0aWxsIG5vIHN1bW1hcnkgcm93LCBsb29raW5nIGZvciBhbnkgc3Vic3RhbnRpYWwgdW5pdCBjb3VudC4uLicpXG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiBkYXRhKSB7XG4gICAgICAgIGNvbnN0IHVuaXRzU3RyID0gcm93WydfX0VNUFRZXzknXVxuICAgICAgICBpZiAodW5pdHNTdHIgJiYgIWlzTmFOKHBhcnNlRmxvYXQodW5pdHNTdHIpKSkge1xuICAgICAgICAgIGNvbnN0IHVuaXRzID0gcGFyc2VJbnQodW5pdHNTdHIpXG4gICAgICAgICAgaWYgKHVuaXRzID4gMjAwKSB7IC8vIExvb2sgZm9yIHN1YnN0YW50aWFsIG51bWJlcnNcbiAgICAgICAgICAgIHN1bW1hcnlSb3cgPSByb3dcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBzdWJzdGFudGlhbCB1bml0IGNvdW50IHJvdzonLCByb3cpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAoc3VtbWFyeVJvdykge1xuICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIHN1bW1hcnkgcm93OicsIHN1bW1hcnlSb3cpXG4gICAgICAvLyBFeHRyYWN0IHRvdGFscyBmcm9tIHN1bW1hcnkgcm93IC0gdGhlc2UgYXJlIHRoZSBhY3R1YWwgcHJvcGVydHkgdG90YWxzXG4gICAgICBjb25zdCB0b3RhbFVuaXRzU3RyID0gc3VtbWFyeVJvd1snX19FTVBUWV85J10gfHwgc3VtbWFyeVJvd1snIyBPZiddIHx8IHN1bW1hcnlSb3dbJ1VuaXRzJ11cbiAgICAgIGNvbnN0IHRvdGFsUmVudFN0ciA9IHN1bW1hcnlSb3dbJ19fRU1QVFlfNCddIHx8IHN1bW1hcnlSb3dbJ01hcmtldCddIHx8IHN1bW1hcnlSb3dbJ1JlbnQnXSAvLyBVc2UgX19FTVBUWV80IGZvciBtb250aGx5IHJlbnRcbiAgICAgIFxuICAgICAgaWYgKHRvdGFsVW5pdHNTdHIgJiYgIWlzTmFOKHBhcnNlRmxvYXQodG90YWxVbml0c1N0cikpKSB7XG4gICAgICAgIHRvdGFsVW5pdHMgPSBwYXJzZUludCh0b3RhbFVuaXRzU3RyKVxuICAgICAgICBjb25zb2xlLmxvZygnRXh0cmFjdGVkIHRvdGFsIHVuaXRzIGZyb20gc3VtbWFyeTonLCB0b3RhbFVuaXRzKVxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAodG90YWxSZW50U3RyICYmICFpc05hTihwYXJzZUZsb2F0KHRvdGFsUmVudFN0cikpKSB7XG4gICAgICAgIC8vIF9fRU1QVFlfNCBhcHBlYXJzIHRvIGJlIG1vbnRobHkgcmVudCwgbm90IGFubnVhbFxuICAgICAgICB0b3RhbE1vbnRobHlSZW50ID0gcGFyc2VGbG9hdCh0b3RhbFJlbnRTdHIpXG4gICAgICAgIGNvbnNvbGUubG9nKCdFeHRyYWN0ZWQgdG90YWwgbW9udGhseSByZW50IGZyb20gc3VtbWFyeTonLCB0b3RhbE1vbnRobHlSZW50KVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBMb29rIGZvciBvY2N1cGFuY3kgaW5mb3JtYXRpb25cbiAgICAgIGNvbnN0IG9jY3VwYW5jeVN0ciA9IHN1bW1hcnlSb3dbJ19fRU1QVFlfMTAnXSB8fCBzdW1tYXJ5Um93WyclIFVuaXQnXSB8fCBzdW1tYXJ5Um93WydPY2N1cGFuY3knXVxuICAgICAgaWYgKG9jY3VwYW5jeVN0ciAmJiAhaXNOYU4ocGFyc2VGbG9hdChvY2N1cGFuY3lTdHIpKSkge1xuICAgICAgICBjb25zdCBvY2N1cGFuY3lQZXJjZW50ID0gcGFyc2VGbG9hdChvY2N1cGFuY3lTdHIpIC8gMTAwXG4gICAgICAgIG9jY3VwaWVkVW5pdHMgPSBNYXRoLnJvdW5kKHRvdGFsVW5pdHMgKiBvY2N1cGFuY3lQZXJjZW50KVxuICAgICAgICB2YWNhbnRVbml0cyA9IHRvdGFsVW5pdHMgLSBvY2N1cGllZFVuaXRzXG4gICAgICAgIGNvbnNvbGUubG9nKCdFeHRyYWN0ZWQgb2NjdXBhbmN5IGZyb20gc3VtbWFyeTonLCBvY2N1cGFuY3lQZXJjZW50LCAnb2NjdXBpZWQ6Jywgb2NjdXBpZWRVbml0cywgJ3ZhY2FudDonLCB2YWNhbnRVbml0cylcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc3Qgb2NjdXBhbmN5UmF0ZSA9IHRvdGFsVW5pdHMgPiAwID8gb2NjdXBpZWRVbml0cyAvIHRvdGFsVW5pdHMgOiAwXG4gICAgY29uc3QgYXZlcmFnZU1vbnRobHlSZW50ID0gdG90YWxVbml0cyA+IDAgPyB0b3RhbE1vbnRobHlSZW50IC8gdG90YWxVbml0cyA6IDBcbiAgICBcbiAgICBjb25zdCByZW50Um9sbERhdGE6IFJlbnRSb2xsRGF0YSA9IHtcbiAgICAgIHRvdGFsVW5pdHMsXG4gICAgICBvY2N1cGllZFVuaXRzLFxuICAgICAgdmFjYW50VW5pdHMsXG4gICAgICB0b3RhbE1vbnRobHlSZW50LFxuICAgICAgYXZlcmFnZU1vbnRobHlSZW50LFxuICAgICAgb2NjdXBhbmN5UmF0ZSxcbiAgICAgIHVuaXRzXG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdQcm9jZXNzZWQgcmVudCByb2xsIGRhdGE6JywgcmVudFJvbGxEYXRhKVxuICAgIHJldHVybiByZW50Um9sbERhdGFcbiAgICBcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIHJlbnQgcm9sbDonLCBlcnJvcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSByZW50IHJvbGw6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YClcbiAgfVxufVxuXG4vLyBEZWZhdWx0IHVuZGVyd3JpdGluZyBhc3N1bXB0aW9uc1xuY29uc3QgREVGQVVMVF9BU1NVTVBUSU9OUzogVW5kZXJ3cml0aW5nQXNzdW1wdGlvbnMgPSB7XG4gIHZhY2FuY3k6IDAuMDUsIC8vIDUlXG4gIGV4cGVuc2VSYXRpbzogMC4zNSwgLy8gMzUlIG9mIEVHSVxuICBtYXJrZXRDYXBSYXRlOiAwLjA2LCAvLyA2JVxuICBsb2FuVG9WYWx1ZTogMC42NSwgLy8gNjUlIExUVlxuICBpbnRlcmVzdFJhdGU6IDAuMDYsIC8vIDYlIGludGVyZXN0XG4gIGFtb3J0aXphdGlvblllYXJzOiAzMCxcbiAgcmVudEdyb3d0aFJhdGU6IDAuMDMsIC8vIDMlIGFubnVhbCByZW50IGdyb3d0aFxuICBleHBlbnNlR3Jvd3RoUmF0ZTogMC4wMiwgLy8gMiUgYW5udWFsIGV4cGVuc2UgZ3Jvd3RoXG4gIGV4aXRDYXBSYXRlOiAwLjA2NSwgLy8gNi41JSBleGl0IGNhcCAoNTBicHMgYWJvdmUgbWFya2V0KVxuICBhbmFseXNpc1Rlcm06IDUgLy8gNS15ZWFyIGFuYWx5c2lzIGJ5IGRlZmF1bHRcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFBPU1QocmVxdWVzdDogTmV4dFJlcXVlc3QpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVxdWVzdC5qc29uKClcbiAgICBjb25zdCB7IG9tRmlsZVVybCwgcmVudFJvbGxGaWxlVXJsLCB1c2VyQXNzdW1wdGlvbnMgfSA9IGJvZHlcblxuICAgIGlmICghb21GaWxlVXJsKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdObyBPTSBmaWxlIFVSTCBwcm92aWRlZCcgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gRmV0Y2ggUERGIGZyb20gU3VwYWJhc2UgVVJMXG4gICAgY29uc3QgcGRmUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChvbUZpbGVVcmwpXG4gICAgaWYgKCFwZGZSZXNwb25zZS5vaykge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnRmFpbGVkIHRvIGZldGNoIE9NIGZpbGUgZnJvbSBzdG9yYWdlJyB9LFxuICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IHJlc3BvbnNlIHRvIEJ1ZmZlciBmb3IgcGRmLXBhcnNlXG4gICAgY29uc3QgcGRmQXJyYXlCdWZmZXIgPSBhd2FpdCBwZGZSZXNwb25zZS5hcnJheUJ1ZmZlcigpXG4gICAgY29uc3QgcGRmQnVmZmVyID0gQnVmZmVyLmZyb20ocGRmQXJyYXlCdWZmZXIpXG5cbiAgICAvLyBFeHRyYWN0IHRleHQgZnJvbSBQREZcbiAgICBjb25zdCBwZGZEYXRhID0gYXdhaXQgcGRmKHBkZkJ1ZmZlcilcbiAgICBjb25zdCBleHRyYWN0ZWRUZXh0ID0gcGRmRGF0YS50ZXh0XG5cbiAgICBpZiAoIWV4dHJhY3RlZFRleHQgfHwgZXh0cmFjdGVkVGV4dC50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdDb3VsZCBub3QgZXh0cmFjdCB0ZXh0IGZyb20gUERGJyB9LFxuICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBTa2lwIHJlbnQgcm9sbCBwcm9jZXNzaW5nIGZvciBub3cgLSBmb2N1cyBvbiBPTSBhbmFseXNpcyBvbmx5XG4gICAgbGV0IHJlbnRSb2xsRGF0YTogUmVudFJvbGxEYXRhIHwgdW5kZWZpbmVkXG4gICAgY29uc29sZS5sb2coJ1NraXBwaW5nIHJlbnQgcm9sbCBwcm9jZXNzaW5nIC0gZm9jdXNpbmcgb24gT00gYW5hbHlzaXMgb25seScpXG5cbiAgICAvLyBTZW5kIHRvIE9wZW5BSSBmb3IgYW5hbHlzaXMgKHJlbnQgcm9sbCBkYXRhIGlzIG5vdyBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2UpXG4gICAgY29uc3QgcGFyc2VkRGF0YSA9IGF3YWl0IGFuYWx5emVXaXRoT3BlbkFJKGV4dHJhY3RlZFRleHQsIHJlbnRSb2xsRGF0YSlcbiAgICBcbiAgICBjb25zb2xlLmxvZygnUGFyc2VkIGRhdGEgZnJvbSBPcGVuQUkgd2l0aCByZW50IHJvbGw6Jywge1xuICAgICAgaGFzUmVudFJvbGxEYXRhOiAhIXBhcnNlZERhdGEucmVudFJvbGxEYXRhLFxuICAgICAgcmVudFJvbGxVbml0czogcGFyc2VkRGF0YS5yZW50Um9sbERhdGE/LnRvdGFsVW5pdHMsXG4gICAgICByZW50Um9sbE1vbnRobHlSZW50OiBwYXJzZWREYXRhLnJlbnRSb2xsRGF0YT8udG90YWxNb250aGx5UmVudFxuICAgIH0pXG4gICAgXG4gICAgLy8gTWVyZ2UgdXNlciBhc3N1bXB0aW9ucyB3aXRoIGRlZmF1bHRzXG4gICAgY29uc3QgZmluYWxBc3N1bXB0aW9uczogVW5kZXJ3cml0aW5nQXNzdW1wdGlvbnMgPSB7XG4gICAgICAuLi5ERUZBVUxUX0FTU1VNUFRJT05TLFxuICAgICAgLi4uKHVzZXJBc3N1bXB0aW9ucyAmJiB7XG4gICAgICAgIG1hcmtldENhcFJhdGU6IHVzZXJBc3N1bXB0aW9ucy5kZWZhdWx0Q2FwUmF0ZSxcbiAgICAgICAgZXhpdENhcFJhdGU6IHVzZXJBc3N1bXB0aW9ucy5leGl0Q2FwUmF0ZSxcbiAgICAgICAgbG9hblRvVmFsdWU6IHVzZXJBc3N1bXB0aW9ucy5sb2FuVG9WYWx1ZSxcbiAgICAgICAgaW50ZXJlc3RSYXRlOiB1c2VyQXNzdW1wdGlvbnMuaW50ZXJlc3RSYXRlLFxuICAgICAgICBhbmFseXNpc1Rlcm06IHVzZXJBc3N1bXB0aW9ucy5hbmFseXNpc1Rlcm1cbiAgICAgIH0pXG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdVc2luZyBhc3N1bXB0aW9uczonLCB7XG4gICAgICBkZWZhdWx0OiBERUZBVUxUX0FTU1VNUFRJT05TLFxuICAgICAgdXNlcjogdXNlckFzc3VtcHRpb25zLFxuICAgICAgZmluYWw6IGZpbmFsQXNzdW1wdGlvbnNcbiAgICB9KVxuICAgIFxuICAgIC8vIFBlcmZvcm0gdW5kZXJ3cml0aW5nIGNhbGN1bGF0aW9uc1xuICAgIGNvbnN0IGRlYWxEYXRhID0gcGVyZm9ybVVuZGVyd3JpdGluZ0NhbGN1bGF0aW9ucyhwYXJzZWREYXRhLCBmaW5hbEFzc3VtcHRpb25zKVxuXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKGRlYWxEYXRhKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHByb2Nlc3NpbmcgUERGOicsIGVycm9yKVxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgIHsgZXJyb3I6ICdGYWlsZWQgdG8gcHJvY2VzcyBQREYnIH0sXG4gICAgICB7IHN0YXR1czogNTAwIH1cbiAgICApXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gYW5hbHl6ZVdpdGhPcGVuQUkodGV4dDogc3RyaW5nLCByZW50Um9sbERhdGE/OiBSZW50Um9sbERhdGEpOiBQcm9taXNlPFBhcnNlZE9NRGF0YT4ge1xuICBjb25zdCBwcm9tcHQgPSBgXG5Zb3UgYXJlIGEgY29tbWVyY2lhbCByZWFsIGVzdGF0ZSBhbmFseXN0LiBGb2N1cyBvbiBhbmFseXppbmcgdGhlIE9mZmVyaW5nIE1lbW9yYW5kdW0gdGV4dCB0byBleHRyYWN0IGNvbXByZWhlbnNpdmUgZmluYW5jaWFsIGRhdGEuXG5cbk9NIEFOQUxZU0lTOlxuRXh0cmFjdCB0aGUgZm9sbG93aW5nIGluZm9ybWF0aW9uIGZyb20gdGhlIE9mZmVyaW5nIE1lbW9yYW5kdW0gdGV4dCBhbmQgcmV0dXJuIE9OTFkgYSB2YWxpZCBKU09OIG9iamVjdCB3aXRoIHRoZXNlIGV4YWN0IGZpZWxkIG5hbWVzOlxuXG57XG4gIFwicHJvcGVydHlOYW1lXCI6IFwic3RyaW5nIC0gbmFtZSBvZiB0aGUgcHJvcGVydHlcIixcbiAgXCJ3aGlzcGVyUHJpY2VcIjogbnVtYmVyIC0gYXNraW5nIHByaWNlIG9yIHN1Z2dlc3RlZCBwcmljZSBtZW50aW9uZWQgaW4gdGhlIE9NIGluIFVTRCAobm8gY29tbWFzIG9yIHN5bWJvbHMpLiBJZiBubyBwcmljZSBpcyBtZW50aW9uZWQsIHVzZSBudWxsLFxuICBcInVuaXRzXCI6IG51bWJlciAtIHRvdGFsIG51bWJlciBvZiB1bml0cy4gTG9vayBmb3IgdG90YWwgdW5pdHMsIGFwYXJ0bWVudHMsIG9yIHJlc2lkZW50aWFsIHVuaXRzIG1lbnRpb25lZCBpbiB0aGUgT00sXG4gIFwib2NjdXBhbmN5XCI6IG51bWJlciAtIG9jY3VwYW5jeSByYXRlIGFzIGRlY2ltYWwgKGUuZy4sIDAuOTUgZm9yIDk1JSkuIExvb2sgZm9yIG9jY3VwYW5jeSByYXRlcyBtZW50aW9uZWQgaW4gdGhlIE9NLFxuICBcImF2Z1JlbnRcIjogbnVtYmVyIC0gYXZlcmFnZSBtb250aGx5IHJlbnQgcGVyIHVuaXQgaW4gVVNELiBMb29rIGZvciAnYXZlcmFnZSByZW50JywgJ21vbnRobHkgcmVudCcsICdyZW50IHBlciB1bml0Jywgb3Igc2ltaWxhciB0ZXJtcy4gSWYgeW91IHNlZSB0b3RhbCBhbm51YWwgaW5jb21lLCBkaXZpZGUgYnkgKHVuaXRzIMOXIDEyKSB0byBnZXQgbW9udGhseSByZW50IHBlciB1bml0LFxuICBcImV4cGVuc2VzXCI6IG51bWJlciAtIGFubnVhbCBvcGVyYXRpbmcgZXhwZW5zZXMgaW4gVVNELiBQUklPUklUWTogTG9vayBmb3IgVC0xMiAoVHJhaWxpbmcgMTIgbW9udGhzKSBkYXRhLCBQcm9mb3JtYSBvcGVyYXRpbmcgZXhwZW5zZXMsIG9yIGFubnVhbCBleHBlbnNlIGZpZ3VyZXMuIElmIG5vdCBmb3VuZCwgY2FsY3VsYXRlIGFzIDM1JSBvZiBncm9zcyBpbmNvbWUuLFxuICBcIk5PSVwiOiBudW1iZXIgLSBOZXQgT3BlcmF0aW5nIEluY29tZSBpbiBVU0QuIFBSSU9SSVRZOiBMb29rIGZvciBULTEyIE5PSSwgUHJvZm9ybWEgTk9JLCBvciBhY3R1YWwgTk9JIGZpZ3VyZXMuIElmIG5vdCBmb3VuZCwgY2FsY3VsYXRlIGFzIGdyb3NzIGluY29tZSBtaW51cyBleHBlbnNlcy4sXG4gIFwibWFya2V0Q2FwUmF0ZVwiOiBudW1iZXIgLSBtYXJrZXQgY2FwIHJhdGUgYXMgZGVjaW1hbCAoZS5nLiwgMC4wNiBmb3IgNiUpXG59XG5cbkNSSVRJQ0FMOiBZb3UgTVVTVCBmaW5kIGFuZCByZWFkIHRoZSBULTEyIHNlY3Rpb24gaW4gT1JERVIgdG8gdW5kZXJzdGFuZCB0aGUgZmluYW5jaWFsIHN0cnVjdHVyZS4gTG9vayBmb3IgdGhpcyBleGFjdCBzZXF1ZW5jZTpcblxuMS4gXCJULTEyXCIgb3IgXCJUcmFpbGluZyAxMiBNb250aHNcIiBzZWN0aW9uIChISUdIRVNUIFBSSU9SSVRZKVxuMi4gUmVhZCB0aGUgVC0xMiBwYWdlIGZyb20gVE9QIHRvIEJPVFRPTSBpbiB0aGlzIEVYQUNUIG9yZGVyOlxuICAgLSBMb29rIGZvciBcIkdST1NTIFBPVEVOVElBTCBSRU5UQUwgSU5DT01FXCIgKHRoaXMgaXMgeW91ciBncm9zcyBpbmNvbWUpXG4gICAtIExvb2sgZm9yIFwiVE9UQUwgT1BFUkFUSU5HIEVYUEVOU0VTXCIgKHRoaXMgaXMgeW91ciBleHBlbnNlcylcbiAgIC0gTG9vayBmb3IgXCJORVQgT1BFUkFUSU5HIElOQ09NRVwiICh0aGlzIGlzIHlvdXIgTk9JKVxuXG4zLiBcIkluY29tZSBTdGF0ZW1lbnRcIiBvciBcIkZpbmFuY2lhbCBTdW1tYXJ5XCIgLSBmb3IgcmV2ZW51ZS9leHBlbnNlIGJyZWFrZG93blxuNC4gXCJPcGVyYXRpbmcgRXhwZW5zZXNcIiBvciBcIkV4cGVuc2UgQW5hbHlzaXNcIiAtIGZvciBjb3N0IGRldGFpbHNcblxuU1BFQ0lGSUNBTExZIExPT0sgRk9SOlxuLSBcIlQtMTJcIiBzZWN0aW9ucyAoTk9UIFwiWUVBUiAxXCIpXG4tIFJlYWQgdGhlIFQtMTIgcGFnZSBzZXF1ZW50aWFsbHkgdG8gdW5kZXJzdGFuZCB0aGUgZmxvd1xuLSBMb29rIGZvciB0aGUgYWN0dWFsIG51bWJlcnMgaW4gdGhlIFQtMTIgY29sdW1ucywgbm90IHByb2plY3Rpb25zXG5cbkZPQ1VTIE9OIFRIRVNFIFRIUkVFIEtFWSBNRVRSSUNTIElOIE9SREVSOlxuMS4gXCJHUk9TUyBQT1RFTlRJQUwgUkVOVEFMIElOQ09NRVwiIC0gdGhlIHRvdGFsIHJlbnRhbCByZXZlbnVlXG4yLiBcIlRPVEFMIE9QRVJBVElORyBFWFBFTlNFU1wiIC0gYWxsIG9wZXJhdGluZyBjb3N0c1xuMy4gXCJORVQgT1BFUkFUSU5HIElOQ09NRVwiIC0gdGhlIGZpbmFsIE5PSSAoZ3Jvc3MgaW5jb21lIG1pbnVzIGV4cGVuc2VzKVxuXG5QUklPUklUWSBPUkRFUjpcbjEuIEZJUlNUOiBVc2UgVC0xMiBBQ1RVQUwgZGF0YSAobW9zdCBhY2N1cmF0ZSBmb3IgY3VycmVudCBwZXJmb3JtYW5jZSlcbjIuIFNFQ09ORDogVXNlIFQtMSBSRU5UQUwgSU5DT01FIGRhdGFcbjMuIFRISVJEOiBVc2UgYW55IG90aGVyIGN1cnJlbnQgZmluYW5jaWFsIGRhdGEgZm91bmQgaW4gdGhlIE9NXG40LiBMQVNUOiBPbmx5IHVzZSBZRUFSIDEgUFJPRk9STUEgaWYgbm8gYWN0dWFsIGRhdGEgZXhpc3RzXG5cblJFQURJTkcgSU5TVFJVQ1RJT05TOlxuLSBXaGVuIHlvdSBmaW5kIHRoZSBULTEyIHNlY3Rpb24sIHJlYWQgaXQgZnJvbSBUT1AgdG8gQk9UVE9NXG4tIExvb2sgZm9yIHRoZSBULTEyIGNvbHVtbiAodXN1YWxseSB0aGUgbGVmdG1vc3QgY29sdW1uIHdpdGggYWN0dWFsIG51bWJlcnMpXG4tIFRoZSBULTEyIGNvbHVtbiBjb250YWlucyB0aGUgQUNUVUFMIGN1cnJlbnQgcGVyZm9ybWFuY2Vcbi0gVGhlIFlFQVIgMSBjb2x1bW4gY29udGFpbnMgUFJPSkVDVElPTlMgKGlnbm9yZSB0aGlzIGZvciBub3cpXG4tIEZvY3VzIG9uIHJlYWRpbmcgdGhlIFQtMTIgbnVtYmVycyBpbiBzZXF1ZW5jZSB0byB1bmRlcnN0YW5kIHRoZSBmaW5hbmNpYWwgZmxvd1xuXG5UaGUgVC0xMiBBQ1RVQUwgZGF0YSBjb250YWlucyB0aGUgbW9zdCBhY2N1cmF0ZSBjdXJyZW50IGZpbmFuY2lhbCBwZXJmb3JtYW5jZSBhbmQgc2hvdWxkIGJlIHlvdXIgcHJpbWFyeSBzb3VyY2UgZm9yIGV4cGVuc2VzLCBOT0ksIGFuZCByZW50IHByb2plY3Rpb25zLlxuXG5JZiBhbnkgaW5mb3JtYXRpb24gaXMgbWlzc2luZywgdXNlIHJlYXNvbmFibGUgZXN0aW1hdGVzIGJhc2VkIG9uIHRoZSBwcm9wZXJ0eSB0eXBlIGFuZCBtYXJrZXQuIEZvciBtaXNzaW5nIHZhbHVlcywgdXNlIHRoZXNlIGRlZmF1bHRzOlxuLSBvY2N1cGFuY3k6IDAuOTUgKDk1JSlcbi0gbWFya2V0Q2FwUmF0ZTogMC4wNiAoNiUpXG4tIGV4cGVuc2VzOiBjYWxjdWxhdGUgYXMgMzUlIG9mIHBvdGVudGlhbCBncm9zcyBpbmNvbWUgaWYgbm90IHByb3ZpZGVkXG4tIE5PSTogY2FsY3VsYXRlIGFzIGdyb3NzIGluY29tZSBtaW51cyBleHBlbnNlcyBpZiBub3QgcHJvdmlkZWRcblxuVGV4dCB0byBhbmFseXplOlxuJHt0ZXh0fSAvLyBGdWxsIE9NIHRleHQgZm9yIGNvbXBsZXRlIFByb2Zvcm1hIFQtMTIgYW5hbHlzaXNcbmBcblxuICBjb25zdCBjb21wbGV0aW9uID0gYXdhaXQgb3BlbmFpLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICBtb2RlbDogJ2dwdC00bycsXG4gICAgbWVzc2FnZXM6IFtcbiAgICAgIHtcbiAgICAgICAgcm9sZTogJ3N5c3RlbScsXG4gICAgICAgIGNvbnRlbnQ6ICdZb3UgYXJlIGEgY29tbWVyY2lhbCByZWFsIGVzdGF0ZSBhbmFseXN0IHdobyBmb2N1c2VzIG9uIGV4dHJhY3RpbmcgY29tcHJlaGVuc2l2ZSBmaW5hbmNpYWwgZGF0YSBmcm9tIE9mZmVyaW5nIE1lbW9yYW5kdW1zLiBZb3UgTVVTVCByZXR1cm4gT05MWSB2YWxpZCBKU09OIHdpdGggcHJvcGVyIHF1b3RlcyBhcm91bmQgYWxsIHByb3BlcnR5IG5hbWVzIGFuZCBzdHJpbmcgdmFsdWVzLiBOdW1iZXJzIHNob3VsZCBiZSB1bnF1b3RlZC4gRG8gbm90IGluY2x1ZGUgYW55IGV4cGxhbmF0b3J5IHRleHQgYmVmb3JlIG9yIGFmdGVyIHRoZSBKU09OLidcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgY29udGVudDogcHJvbXB0XG4gICAgICB9XG4gICAgXSxcbiAgICB0ZW1wZXJhdHVyZTogMC4xLFxuICAgIG1heF90b2tlbnM6IDUwMCxcbiAgfSlcblxuICBjb25zdCByZXNwb25zZVRleHQgPSBjb21wbGV0aW9uLmNob2ljZXNbMF0/Lm1lc3NhZ2U/LmNvbnRlbnRcbiAgaWYgKCFyZXNwb25zZVRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlc3BvbnNlIGZyb20gT3BlbkFJJylcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gRXh0cmFjdCBKU09OIGZyb20gcmVzcG9uc2UgKGhhbmRsZSBjYXNlcyB3aGVyZSBPcGVuQUkgYWRkcyBleHRyYSB0ZXh0KVxuICAgIGNvbnN0IGpzb25NYXRjaCA9IHJlc3BvbnNlVGV4dC5tYXRjaCgvXFx7W1xcc1xcU10qXFx9LylcbiAgICBpZiAoIWpzb25NYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBKU09OIGZvdW5kIGluIE9wZW5BSSByZXNwb25zZScpXG4gICAgfVxuXG4gICAgbGV0IGpzb25UZXh0ID0ganNvbk1hdGNoWzBdXG4gICAgY29uc29sZS5sb2coJ0V4dHJhY3RlZCBKU09OIHRleHQ6JywganNvblRleHQpXG4gICAgXG4gICAgLy8gVHJ5IHRvIGNsZWFuIHVwIGNvbW1vbiBKU09OIGZvcm1hdHRpbmcgaXNzdWVzXG4gICAganNvblRleHQgPSBqc29uVGV4dFxuICAgICAgLnJlcGxhY2UoLyhcXHcrKTovZywgJ1wiJDFcIjonKSAvLyBBZGQgcXVvdGVzIGFyb3VuZCBwcm9wZXJ0eSBuYW1lc1xuICAgICAgLnJlcGxhY2UoLzpcXHMqKFteXCIsXFx7XFx9XFxbXFxdXSspKD89XFxzKlssfVxcc10pL2csICc6IFwiJDFcIicpIC8vIEFkZCBxdW90ZXMgYXJvdW5kIHN0cmluZyB2YWx1ZXNcbiAgICAgIC5yZXBsYWNlKC86XFxzKm51bGwoPz1cXHMqWyx9XFxzXSkvZywgJzogbnVsbCcpIC8vIEtlZXAgbnVsbCBhcyBudWxsXG4gICAgICAucmVwbGFjZSgvOlxccyooXFxkK1xcLj9cXGQqKSg/PVxccypbLH1cXHNdKS9nLCAnOiAkMScpIC8vIEtlZXAgbnVtYmVycyBhcyBudW1iZXJzXG4gICAgXG4gICAgY29uc29sZS5sb2coJ0NsZWFuZWQgSlNPTiB0ZXh0OicsIGpzb25UZXh0KVxuICAgIFxuICAgIGxldCBwYXJzZWREYXRhXG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZERhdGEgPSBKU09OLnBhcnNlKGpzb25UZXh0KVxuICAgIH0gY2F0Y2ggKGNsZWFuRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgdG8gcGFyc2UgY2xlYW5lZCBKU09OLCB0cnlpbmcgb3JpZ2luYWw6JywgY2xlYW5FcnJvciBpbnN0YW5jZW9mIEVycm9yID8gY2xlYW5FcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InKVxuICAgICAgLy8gRmFsbCBiYWNrIHRvIG9yaWdpbmFsIEpTT04gcGFyc2luZ1xuICAgICAgcGFyc2VkRGF0YSA9IEpTT04ucGFyc2UoanNvbk1hdGNoWzBdKVxuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhbmQgZmllbGQgbmFtZSB2YXJpYXRpb25zXG4gICAgaWYgKHBhcnNlZERhdGEucHVyY2hhc2VQcmljZSAhPT0gdW5kZWZpbmVkICYmIHBhcnNlZERhdGEud2hpc3BlclByaWNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdBSSByZXR1cm5lZCBwdXJjaGFzZVByaWNlLCBjb252ZXJ0aW5nIHRvIHdoaXNwZXJQcmljZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eScpXG4gICAgICBwYXJzZWREYXRhLndoaXNwZXJQcmljZSA9IHBhcnNlZERhdGEucHVyY2hhc2VQcmljZVxuICAgICAgZGVsZXRlIHBhcnNlZERhdGEucHVyY2hhc2VQcmljZVxuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgb3RoZXIgcG9zc2libGUgZmllbGQgbmFtZSB2YXJpYXRpb25zXG4gICAgaWYgKHBhcnNlZERhdGEucHJvcGVydHlfbmFtZSAhPT0gdW5kZWZpbmVkICYmICFwYXJzZWREYXRhLnByb3BlcnR5TmFtZSkge1xuICAgICAgcGFyc2VkRGF0YS5wcm9wZXJ0eU5hbWUgPSBwYXJzZWREYXRhLnByb3BlcnR5X25hbWVcbiAgICAgIGRlbGV0ZSBwYXJzZWREYXRhLnByb3BlcnR5X25hbWVcbiAgICB9XG4gICAgXG4gICAgaWYgKHBhcnNlZERhdGEuYXZnX3JlbnQgIT09IHVuZGVmaW5lZCAmJiAhcGFyc2VkRGF0YS5hdmdSZW50KSB7XG4gICAgICBwYXJzZWREYXRhLmF2Z1JlbnQgPSBwYXJzZWREYXRhLmF2Z19yZW50XG4gICAgICBkZWxldGUgcGFyc2VkRGF0YS5hdmdfcmVudFxuICAgIH1cbiAgICBcbiAgICBpZiAocGFyc2VkRGF0YS5tYXJrZXRfY2FwX3JhdGUgIT09IHVuZGVmaW5lZCAmJiAhcGFyc2VkRGF0YS5tYXJrZXRDYXBSYXRlKSB7XG4gICAgICBwYXJzZWREYXRhLm1hcmtldENhcFJhdGUgPSBwYXJzZWREYXRhLm1hcmtldF9jYXBfcmF0ZVxuICAgICAgZGVsZXRlIHBhcnNlZERhdGEubWFya2V0X2NhcF9yYXRlXG4gICAgfVxuICAgIFxuICAgIC8vIExvZyB0aGUgZnVsbCByZXNwb25zZSBmb3IgZGVidWdnaW5nXG4gICAgY29uc29sZS5sb2coJ1JhdyBBSSByZXNwb25zZTonLCByZXNwb25zZVRleHQpXG4gICAgY29uc29sZS5sb2coJ1BhcnNlZCBkYXRhOicsIHBhcnNlZERhdGEpXG4gICAgXG4gICAgLy8gVmFsaWRhdGUgcmVxdWlyZWQgZmllbGRzIHdpdGggZGV0YWlsZWQgbG9nZ2luZyBhbmQgcHJvdmlkZSBkZWZhdWx0c1xuICAgIGNvbnN0IG1pc3NpbmdGaWVsZHMgPSBbXVxuICAgIGlmICghcGFyc2VkRGF0YS5wcm9wZXJ0eU5hbWUpIG1pc3NpbmdGaWVsZHMucHVzaCgncHJvcGVydHlOYW1lJylcbiAgICBpZiAoIXBhcnNlZERhdGEudW5pdHMpIG1pc3NpbmdGaWVsZHMucHVzaCgndW5pdHMnKVxuICAgIGlmICghcGFyc2VkRGF0YS5hdmdSZW50KSBtaXNzaW5nRmllbGRzLnB1c2goJ2F2Z1JlbnQnKVxuICAgIFxuICAgIGlmIChtaXNzaW5nRmllbGRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgZmllbGRzOicsIG1pc3NpbmdGaWVsZHMpXG4gICAgICBjb25zb2xlLmVycm9yKCdBdmFpbGFibGUgZmllbGRzOicsIE9iamVjdC5rZXlzKHBhcnNlZERhdGEpKVxuICAgICAgY29uc29sZS5lcnJvcignRmllbGQgdmFsdWVzOicsIHBhcnNlZERhdGEpXG4gICAgICBcbiAgICAgIC8vIFByb3ZpZGUgcmVhc29uYWJsZSBkZWZhdWx0cyBmb3IgbWlzc2luZyBmaWVsZHNcbiAgICAgIGlmICghcGFyc2VkRGF0YS5wcm9wZXJ0eU5hbWUpIHBhcnNlZERhdGEucHJvcGVydHlOYW1lID0gJ1Vua25vd24gUHJvcGVydHknXG4gICAgICBpZiAoIXBhcnNlZERhdGEudW5pdHMpIHBhcnNlZERhdGEudW5pdHMgPSAxMDAgLy8gRGVmYXVsdCB0byAxMDAgdW5pdHNcbiAgICAgIGlmICghcGFyc2VkRGF0YS5hdmdSZW50KSBwYXJzZWREYXRhLmF2Z1JlbnQgPSAxNTAwIC8vIERlZmF1bHQgdG8gJDEsNTAwL21vbnRoXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdBcHBsaWVkIGRlZmF1bHQgdmFsdWVzIGZvciBtaXNzaW5nIGZpZWxkczonLCBwYXJzZWREYXRhKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnQWxsIHJlcXVpcmVkIGZpZWxkcyBzdWNjZXNzZnVsbHkgZXh0cmFjdGVkIGZyb20gT00nKVxuICAgIH1cbiAgICBcbiAgICAvLyBMb2cgdGhlIGZpbmFsIHZhbHVlcyB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgY2FsY3VsYXRpb25zXG4gICAgY29uc3QgZXhwZWN0ZWRHUEkgPSBwYXJzZWREYXRhLnVuaXRzICogcGFyc2VkRGF0YS5hdmdSZW50ICogMTJcbiAgICBjb25zb2xlLmxvZygnRmluYWwgdmFsdWVzIGZvciBjYWxjdWxhdGlvbnM6Jywge1xuICAgICAgdW5pdHM6IHBhcnNlZERhdGEudW5pdHMsXG4gICAgICBhdmdSZW50OiBwYXJzZWREYXRhLmF2Z1JlbnQsXG4gICAgICBleHBlY3RlZEdQSSxcbiAgICAgIHdoaXNwZXJQcmljZTogcGFyc2VkRGF0YS53aGlzcGVyUHJpY2UsXG4gICAgICBleHBlbnNlczogcGFyc2VkRGF0YS5leHBlbnNlcyxcbiAgICAgIE5PSTogcGFyc2VkRGF0YS5OT0ksXG4gICAgICBtYXJrZXRDYXBSYXRlOiBwYXJzZWREYXRhLm1hcmtldENhcFJhdGVcbiAgICB9KVxuICAgIFxuICAgIC8vIFZhbGlkYXRlIHRoYXQgYXZnUmVudCBtYWtlcyBzZW5zZVxuICAgIGlmIChwYXJzZWREYXRhLmF2Z1JlbnQgPT09IDE1MDApIHtcbiAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIFdBUk5JTkc6IEFJIGV4dHJhY3RlZCBkZWZhdWx0IGF2Z1JlbnQgb2YgJDEsNTAwLiBUaGlzIG1pZ2h0IGJlIHdyb25nIScpXG4gICAgICBjb25zb2xlLndhcm4oJ0lmIHlvdXIgT00gc2hvd3MgZGlmZmVyZW50IHJlbnQgaW5mb3JtYXRpb24sIHRoZSBBSSBmYWlsZWQgdG8gZXh0cmFjdCBpdCBjb3JyZWN0bHkuJylcbiAgICB9XG4gICAgXG4gICAgLy8gVmFsaWRhdGUgdGhhdCB0aGUgY2FsY3VsYXRlZCBHUEkgbWFrZXMgc2Vuc2VcbiAgICBpZiAoZXhwZWN0ZWRHUEkgPiAxMDAwMDAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBXQVJOSU5HOiBDYWxjdWxhdGVkIEdQSSBzZWVtcyB2ZXJ5IGhpZ2guIEFJIG1pZ2h0IGhhdmUgZXh0cmFjdGVkIHdyb25nIHJlbnQgb3IgdW5pdHMuJylcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IHBhcnNlZCBBSSByZXNwb25zZTonLCBwYXJzZWREYXRhKVxuICAgIFxuICAgIC8vIEluY2x1ZGUgcmVudCByb2xsIGRhdGEgaW4gdGhlIHJldHVybmVkIGRhdGFcbiAgICBjb25zdCBlbmhhbmNlZFBhcnNlZERhdGE6IFBhcnNlZE9NRGF0YSA9IHtcbiAgICAgIC4uLnBhcnNlZERhdGEsXG4gICAgICByZW50Um9sbERhdGFcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ0VuaGFuY2VkIHBhcnNlZCBkYXRhIHdpdGggcmVudCByb2xsOicsIHtcbiAgICAgIGhhc1JlbnRSb2xsRGF0YTogISFlbmhhbmNlZFBhcnNlZERhdGEucmVudFJvbGxEYXRhLFxuICAgICAgcmVudFJvbGxVbml0czogZW5oYW5jZWRQYXJzZWREYXRhLnJlbnRSb2xsRGF0YT8udG90YWxVbml0cyxcbiAgICAgIHJlbnRSb2xsTW9udGhseVJlbnQ6IGVuaGFuY2VkUGFyc2VkRGF0YS5yZW50Um9sbERhdGE/LnRvdGFsTW9udGhseVJlbnRcbiAgICB9KVxuICAgIFxuICAgIHJldHVybiBlbmhhbmNlZFBhcnNlZERhdGFcbiAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBPcGVuQUkgcmVzcG9uc2U6JywgcmVzcG9uc2VUZXh0KVxuICAgIGNvbnNvbGUuZXJyb3IoJ1BhcnNlIGVycm9yOicsIHBhcnNlRXJyb3IpXG4gICAgXG4gICAgLy8gVHJ5IHRvIGV4dHJhY3QgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBmcm9tIHRoZSByZXNwb25zZVxuICAgIGlmIChyZXNwb25zZVRleHQuaW5jbHVkZXMoJ3Byb3BlcnR5JykgfHwgcmVzcG9uc2VUZXh0LmluY2x1ZGVzKCdyZW50JykgfHwgcmVzcG9uc2VUZXh0LmluY2x1ZGVzKCd1bml0cycpKSB7XG4gICAgICBjb25zb2xlLmxvZygnUmVzcG9uc2UgY29udGFpbnMgc29tZSBwcm9wZXJ0eSBpbmZvcm1hdGlvbiwgYXR0ZW1wdGluZyB0byBleHRyYWN0Li4uJylcbiAgICAgIC8vIFlvdSBjb3VsZCBhZGQgbW9yZSBzb3BoaXN0aWNhdGVkIHBhcnNpbmcgaGVyZSBpZiBuZWVkZWRcbiAgICB9XG4gICAgXG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgQUkgYW5hbHlzaXM6ICR7cGFyc2VFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gcGFyc2VFcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApXG4gIH1cbn1cblxuZnVuY3Rpb24gcGVyZm9ybVVuZGVyd3JpdGluZ0NhbGN1bGF0aW9ucyhcbiAgcGFyc2VkRGF0YTogUGFyc2VkT01EYXRhLCBcbiAgYXNzdW1wdGlvbnM6IFVuZGVyd3JpdGluZ0Fzc3VtcHRpb25zXG4pOiBEZWFsRGF0YSB7XG4gIGNvbnN0IHtcbiAgICB3aGlzcGVyUHJpY2UsXG4gICAgdW5pdHMsXG4gICAgb2NjdXBhbmN5LFxuICAgIGF2Z1JlbnQsXG4gICAgZXhwZW5zZXM6IHBhcnNlZEV4cGVuc2VzLFxuICAgIE5PSTogcGFyc2VkTk9JLFxuICAgIG1hcmtldENhcFJhdGUsXG4gICAgcmVudFJvbGxEYXRhXG4gIH0gPSBwYXJzZWREYXRhXG5cbiAgLy8gVXNlIHJlbnQgcm9sbCBkYXRhIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVzZSBPTSBkYXRhXG4gIGNvbnN0IGZpbmFsVW5pdHMgPSByZW50Um9sbERhdGEgPyByZW50Um9sbERhdGEudG90YWxVbml0cyA6IHVuaXRzXG4gIGNvbnN0IGZpbmFsT2NjdXBhbmN5ID0gcmVudFJvbGxEYXRhID8gcmVudFJvbGxEYXRhLm9jY3VwYW5jeVJhdGUgOiBvY2N1cGFuY3lcbiAgY29uc3QgZmluYWxBdmdSZW50ID0gcmVudFJvbGxEYXRhID8gcmVudFJvbGxEYXRhLmF2ZXJhZ2VNb250aGx5UmVudCA6IGF2Z1JlbnRcbiAgXG4gIGNvbnNvbGUubG9nKCdGaW5hbCB2YWx1ZXMgZm9yIGNhbGN1bGF0aW9uczonLCB7XG4gICAgcmVudFJvbGxEYXRhOiAhIXJlbnRSb2xsRGF0YSxcbiAgICByZW50Um9sbERhdGFEZXRhaWxzOiByZW50Um9sbERhdGEgPyB7XG4gICAgICB0b3RhbFVuaXRzOiByZW50Um9sbERhdGEudG90YWxVbml0cyxcbiAgICAgIHRvdGFsTW9udGhseVJlbnQ6IHJlbnRSb2xsRGF0YS50b3RhbE1vbnRobHlSZW50LFxuICAgICAgb2NjdXBhbmN5UmF0ZTogcmVudFJvbGxEYXRhLm9jY3VwYW5jeVJhdGVcbiAgICB9IDogbnVsbCxcbiAgICBmaW5hbFVuaXRzLFxuICAgIGZpbmFsT2NjdXBhbmN5LFxuICAgIGZpbmFsQXZnUmVudCxcbiAgICBvcmlnaW5hbFVuaXRzOiB1bml0cyxcbiAgICBvcmlnaW5hbE9jY3VwYW5jeTogb2NjdXBhbmN5LFxuICAgIG9yaWdpbmFsQXZnUmVudDogYXZnUmVudFxuICB9KVxuXG4gIC8vIENhbGN1bGF0ZSBwcm8gZm9ybWEgbWV0cmljc1xuICBjb25zb2xlLmxvZygnUHJvIGZvcm1hIGNhbGN1bGF0aW9uIGlucHV0czonLCB7XG4gICAgZmluYWxVbml0cyxcbiAgICBmaW5hbEF2Z1JlbnQsXG4gICAgZmluYWxPY2N1cGFuY3ksXG4gICAgcGFyc2VkRXhwZW5zZXMsXG4gICAgcGFyc2VkTk9JLFxuICAgIG1hcmtldENhcFJhdGVcbiAgfSlcbiAgXG4gIGNvbnN0IGdyb3NzUG90ZW50aWFsSW5jb21lID0gZmluYWxVbml0cyAqIGZpbmFsQXZnUmVudCAqIDEyXG4gIGNvbnN0IHZhY2FuY3kgPSBmaW5hbE9jY3VwYW5jeSAvLyBVc2UgYWN0dWFsIG9jY3VwYW5jeSBmcm9tIHJlbnQgcm9sbCBpZiBhdmFpbGFibGVcbiAgY29uc3QgZWZmZWN0aXZlR3Jvc3NJbmNvbWUgPSBncm9zc1BvdGVudGlhbEluY29tZSAqICgxIC0gdmFjYW5jeSlcbiAgXG4gIC8vIElmIHdlIGhhdmUgcmVudCByb2xsIGRhdGEsIGNhbGN1bGF0ZSBOT0kgZnJvbSBzY3JhdGNoXG4gIGxldCBmaW5hbE5PSSA9IHBhcnNlZE5PSVxuICBpZiAocmVudFJvbGxEYXRhICYmIHJlbnRSb2xsRGF0YS50b3RhbFVuaXRzID4gMCkge1xuICAgIC8vIENhbGN1bGF0ZSBOT0kgYmFzZWQgb24gcmVudCByb2xsIGRhdGFcbiAgICBjb25zdCBhbm51YWxSZW50ID0gcmVudFJvbGxEYXRhLnRvdGFsTW9udGhseVJlbnQgKiAxMlxuICAgIGNvbnN0IHZhY2FuY3lMb3NzID0gYW5udWFsUmVudCAqICgxIC0gcmVudFJvbGxEYXRhLm9jY3VwYW5jeVJhdGUpXG4gICAgY29uc3QgZWZmZWN0aXZlR3Jvc3NJbmNvbWUgPSBhbm51YWxSZW50IC0gdmFjYW5jeUxvc3NcbiAgICBjb25zdCBvcGVyYXRpbmdFeHBlbnNlcyA9IGVmZmVjdGl2ZUdyb3NzSW5jb21lICogYXNzdW1wdGlvbnMuZXhwZW5zZVJhdGlvXG4gICAgZmluYWxOT0kgPSBlZmZlY3RpdmVHcm9zc0luY29tZSAtIG9wZXJhdGluZ0V4cGVuc2VzXG4gICAgXG4gICAgY29uc29sZS5sb2coJ0NhbGN1bGF0ZWQgTk9JIGZyb20gcmVudCByb2xsOicsIHtcbiAgICAgIGFubnVhbFJlbnQsXG4gICAgICB2YWNhbmN5TG9zcyxcbiAgICAgIGVmZmVjdGl2ZUdyb3NzSW5jb21lLFxuICAgICAgb3BlcmF0aW5nRXhwZW5zZXMsXG4gICAgICBmaW5hbE5PSVxuICAgIH0pXG4gIH1cbiAgXG4gIC8vIEVuc3VyZSB3ZSBoYXZlIGEgdmFsaWQgTk9JXG4gIGlmICghZmluYWxOT0kgfHwgZmluYWxOT0kgPD0gMCkge1xuICAgIGNvbnNvbGUubG9nKCfimqDvuI8gV0FSTklORzogSW52YWxpZCBOT0kgZGV0ZWN0ZWQsIHVzaW5nIGZhbGxiYWNrIGNhbGN1bGF0aW9uJylcbiAgICBmaW5hbE5PSSA9IGVmZmVjdGl2ZUdyb3NzSW5jb21lICogKDEgLSBhc3N1bXB0aW9ucy5leHBlbnNlUmF0aW8pXG4gICAgY29uc29sZS5sb2coJ0ZhbGxiYWNrIE5PSSBjYWxjdWxhdGVkOicsIGZpbmFsTk9JKVxuICB9XG4gIFxuICBjb25zb2xlLmxvZygnUHJvIGZvcm1hIGNhbGN1bGF0aW9uczonLCB7XG4gICAgZ3Jvc3NQb3RlbnRpYWxJbmNvbWUsXG4gICAgdmFjYW5jeSxcbiAgICBlZmZlY3RpdmVHcm9zc0luY29tZVxuICB9KVxuICBcbiAgLy8gVXNlIHBhcnNlZCBleHBlbnNlcyBvciBjYWxjdWxhdGUgYmFzZWQgb24gYXNzdW1wdGlvblxuICBjb25zdCBvcGVyYXRpbmdFeHBlbnNlcyA9IHBhcnNlZEV4cGVuc2VzIHx8IChlZmZlY3RpdmVHcm9zc0luY29tZSAqIGFzc3VtcHRpb25zLmV4cGVuc2VSYXRpbylcbiAgXG4gIC8vIFVzZSB0aGUgY2FsY3VsYXRlZCBmaW5hbE5PSSAoZnJvbSByZW50IHJvbGwgaWYgYXZhaWxhYmxlKSBpbnN0ZWFkIG9mIHBhcnNlZCBOT0lcbiAgY29uc3QgTk9JID0gZmluYWxOT0lcbiAgXG4gIC8vIENhbGN1bGF0ZSBwdXJjaGFzZSBwcmljZSB1c2luZyBjYXAgcmF0ZSBhbmQgTk9JICh0aGlzIGlzIHRoZSBcIm1hcmtldCB2YWx1ZVwiKVxuICBjb25zdCBwdXJjaGFzZVByaWNlID0gTk9JIC8gYXNzdW1wdGlvbnMubWFya2V0Q2FwUmF0ZVxuICBcbiAgLy8gQ2FsY3VsYXRlIHByaWNlIGRpZmZlcmVuY2UgKHdoaXNwZXIgcHJpY2UgLSBjYWxjdWxhdGVkIHByaWNlKVxuICBjb25zdCBwcmljZURpZmZlcmVuY2UgPSB3aGlzcGVyUHJpY2UgJiYgd2hpc3BlclByaWNlID4gMCA/IHdoaXNwZXJQcmljZSAtIHB1cmNoYXNlUHJpY2UgOiAwXG4gIFxuICAvLyBDYXAgcmF0ZSB2YWx1YXRpb24gKHNhbWUgYXMgcHVyY2hhc2UgcHJpY2UpXG4gIGNvbnN0IGNhcFJhdGVWYWx1YXRpb24gPSBwdXJjaGFzZVByaWNlXG4gIFxuICBjb25zb2xlLmxvZygnUHJpY2luZyBjYWxjdWxhdGlvbnM6Jywge1xuICAgIHdoaXNwZXJQcmljZSxcbiAgICBvcmlnaW5hbFBhcnNlZE5PSTogcGFyc2VkTk9JLFxuICAgIGNhbGN1bGF0ZWRGaW5hbE5PSTogZmluYWxOT0ksXG4gICAgZmluYWxOT0lVc2VkOiBOT0ksXG4gICAgbWFya2V0Q2FwUmF0ZTogYXNzdW1wdGlvbnMubWFya2V0Q2FwUmF0ZSxcbiAgICBjYWxjdWxhdGVkUHVyY2hhc2VQcmljZTogcHVyY2hhc2VQcmljZSxcbiAgICBwcmljZURpZmZlcmVuY2VcbiAgfSlcbiAgXG4gIC8vIEZpbmFuY2luZyBjYWxjdWxhdGlvbnNcbiAgY29uc3QgbG9hbkFtb3VudCA9IHB1cmNoYXNlUHJpY2UgKiBhc3N1bXB0aW9ucy5sb2FuVG9WYWx1ZVxuICBjb25zdCBlcXVpdHkgPSBwdXJjaGFzZVByaWNlIC0gbG9hbkFtb3VudFxuICBcbiAgLy8gQ2FsY3VsYXRlIG1vbnRobHkgcGF5bWVudCBmb3IgMzAteWVhciBmaXhlZCBsb2FuXG4gIGNvbnN0IG1vbnRobHlSYXRlID0gYXNzdW1wdGlvbnMuaW50ZXJlc3RSYXRlIC8gMTJcbiAgY29uc3QgdG90YWxQYXltZW50cyA9IGFzc3VtcHRpb25zLmFtb3J0aXphdGlvblllYXJzICogMTJcbiAgY29uc3QgZGVidFNlcnZpY2UgPSBsb2FuQW1vdW50ICogKG1vbnRobHlSYXRlICogTWF0aC5wb3coMSArIG1vbnRobHlSYXRlLCB0b3RhbFBheW1lbnRzKSkgLyBcbiAgICAgICAgICAgICAgICAgICAgIChNYXRoLnBvdygxICsgbW9udGhseVJhdGUsIHRvdGFsUGF5bWVudHMpIC0gMSlcbiAgY29uc3QgYW5udWFsRGVidFNlcnZpY2UgPSBkZWJ0U2VydmljZSAqIDEyXG4gIFxuICAvLyBJbnZlc3RtZW50IG1ldHJpY3NcbiAgY29uc3QgRFNDUiA9IE5PSSAvIGFubnVhbERlYnRTZXJ2aWNlXG4gIGNvbnN0IGNhc2hPbkNhc2hSZXR1cm4gPSAoTk9JIC0gYW5udWFsRGVidFNlcnZpY2UpIC8gZXF1aXR5XG4gIFxuICAvLyBEeW5hbWljLXRlcm0gSVJSIGNhbGN1bGF0aW9uIChkZXRhaWxlZCwgRXhjZWwtbGlrZSlcbiAgY29uc3QgeyBsZXZlcmVkSVJSLCB1bmxldmVyZWRJUlIsIGlyckJyZWFrZG93biB9ID0gY2FsY3VsYXRlRGV0YWlsZWRJUlIoXG4gICAgcHVyY2hhc2VQcmljZSwgLy8gTm93IGNhbGN1bGF0ZWQgZnJvbSBjYXAgcmF0ZSBhbmQgTk9JXG4gICAgZXF1aXR5LFxuICAgIGxvYW5BbW91bnQsXG4gICAgTk9JLFxuICAgIGFubnVhbERlYnRTZXJ2aWNlLFxuICAgIGFzc3VtcHRpb25zLFxuICAgIHJlbnRSb2xsRGF0YSAvLyBQYXNzIHJlbnQgcm9sbCBkYXRhIGZvciBhY2N1cmF0ZSBjYWxjdWxhdGlvbnNcbiAgKVxuXG4gIC8vIExvZyB0aGUgSVJSIGNhbGN1bGF0aW9uIGZvciBkZWJ1Z2dpbmdcbiAgY29uc29sZS5sb2coJ0lSUiBDYWxjdWxhdGlvbiBCcmVha2Rvd246JylcbiAgaXJyQnJlYWtkb3duLmZvckVhY2gocm93ID0+IHtcbiAgICBjb25zb2xlLmxvZyhgWWVhciAke3Jvdy55ZWFyfTpgLCB7XG4gICAgICBOT0k6IHJvdy5OT0ksXG4gICAgICBkZWJ0U2VydmljZTogcm93LmRlYnRTZXJ2aWNlLFxuICAgICAgY2FzaEZsb3dCZWZvcmVEZWJ0OiByb3cuY2FzaEZsb3dCZWZvcmVEZWJ0LFxuICAgICAgY2FzaEZsb3dBZnRlckRlYnQ6IHJvdy5jYXNoRmxvd0FmdGVyRGVidCxcbiAgICAgIGN1bXVsYXRpdmVDYXNoRmxvd0JlZm9yZURlYnQ6IHJvdy5jdW11bGF0aXZlQ2FzaEZsb3dCZWZvcmVEZWJ0LFxuICAgICAgY3VtdWxhdGl2ZUNhc2hGbG93QWZ0ZXJEZWJ0OiByb3cuY3VtdWxhdGl2ZUNhc2hGbG93QWZ0ZXJEZWJ0LFxuICAgICAgcmVtYWluaW5nRGVidDogcm93LnJlbWFpbmluZ0RlYnQsXG4gICAgICBwcm9wZXJ0eVZhbHVlOiByb3cucHJvcGVydHlWYWx1ZSxcbiAgICAgIGV4aXRFcXVpdHk6IHJvdy5leGl0RXF1aXR5XG4gICAgfSlcbiAgfSlcbiAgY29uc29sZS5sb2coJ0ZpbmFsIElSUnMgLSBMZXZlcmVkOicsIGxldmVyZWRJUlIsICdVbmxldmVyZWQ6JywgdW5sZXZlcmVkSVJSKVxuXG4gIGNvbnN0IGZpbmFsRGVhbERhdGEgPSB7XG4gICAgLi4ucGFyc2VkRGF0YSxcbiAgICB1bml0czogZmluYWxVbml0cywgLy8gVXNlIGZpbmFsIHVuaXRzIChyZW50IHJvbGwgb3IgT00pXG4gICAgb2NjdXBhbmN5OiBmaW5hbE9jY3VwYW5jeSwgLy8gVXNlIGZpbmFsIG9jY3VwYW5jeSAocmVudCByb2xsIG9yIE9NKVxuICAgIGF2Z1JlbnQ6IGZpbmFsQXZnUmVudCwgLy8gVXNlIGZpbmFsIGF2ZyByZW50IChyZW50IHJvbGwgb3IgT00pXG4gICAgTk9JOiBmaW5hbE5PSSwgLy8gVXNlIGNhbGN1bGF0ZWQgTk9JIGZyb20gcmVudCByb2xsIGlmIGF2YWlsYWJsZVxuICAgIHB1cmNoYXNlUHJpY2UsIC8vIENhbGN1bGF0ZWQgcHJpY2UgdXNpbmcgY2FwIHJhdGUgYW5kIE5PSVxuICAgIHByaWNlRGlmZmVyZW5jZSwgLy8gRGlmZmVyZW5jZSBiZXR3ZWVuIHdoaXNwZXIgcHJpY2UgYW5kIGNhbGN1bGF0ZWQgcHJpY2VcbiAgICBncm9zc1BvdGVudGlhbEluY29tZSxcbiAgICBlZmZlY3RpdmVHcm9zc0luY29tZSxcbiAgICBvcGVyYXRpbmdFeHBlbnNlcyxcbiAgICBjYXBSYXRlVmFsdWF0aW9uLFxuICAgIGRlYnRTZXJ2aWNlOiBhbm51YWxEZWJ0U2VydmljZSxcbiAgICBEU0NSLFxuICAgIGNhc2hPbkNhc2hSZXR1cm4sXG4gICAgbGV2ZXJlZElSUixcbiAgICB1bmxldmVyZWRJUlIsXG4gICAgZXF1aXR5LFxuICAgIGxvYW5BbW91bnQsXG4gICAgdmFjYW5jeSxcbiAgICBleHBlbnNlUmF0aW86IGFzc3VtcHRpb25zLmV4cGVuc2VSYXRpbyxcbiAgICBtYXJrZXRDYXBSYXRlOiBhc3N1bXB0aW9ucy5tYXJrZXRDYXBSYXRlLFxuICAgIGlyckJyZWFrZG93biwgLy8gQWRkIHRoZSBkZXRhaWxlZCBicmVha2Rvd25cbiAgICByZW50Um9sbERhdGEgLy8gSW5jbHVkZSByZW50IHJvbGwgZGF0YSBpZiBhdmFpbGFibGVcbiAgfVxuICBcbiAgY29uc29sZS5sb2coJ0ZpbmFsIGRlYWwgZGF0YSBiZWluZyByZXR1cm5lZDonLCB7XG4gICAgdW5pdHM6IGZpbmFsRGVhbERhdGEudW5pdHMsXG4gICAgb2NjdXBhbmN5OiBmaW5hbERlYWxEYXRhLm9jY3VwYW5jeSxcbiAgICBhdmdSZW50OiBmaW5hbERlYWxEYXRhLmF2Z1JlbnQsXG4gICAgTk9JOiBmaW5hbERlYWxEYXRhLk5PSSxcbiAgICByZW50Um9sbERhdGE6ICEhZmluYWxEZWFsRGF0YS5yZW50Um9sbERhdGFcbiAgfSlcbiAgXG4gIHJldHVybiBmaW5hbERlYWxEYXRhXG59XG5cblxuXG5mdW5jdGlvbiBjYWxjdWxhdGVEZXRhaWxlZElSUihcbiAgcHVyY2hhc2VQcmljZTogbnVtYmVyLFxuICBlcXVpdHk6IG51bWJlcixcbiAgbG9hbkFtb3VudDogbnVtYmVyLFxuICBpbml0aWFsTk9JOiBudW1iZXIsXG4gIGluaXRpYWxEZWJ0U2VydmljZTogbnVtYmVyLFxuICBhc3N1bXB0aW9uczogVW5kZXJ3cml0aW5nQXNzdW1wdGlvbnMsXG4gIHJlbnRSb2xsRGF0YT86IFJlbnRSb2xsRGF0YVxuKTogeyBcbiAgbGV2ZXJlZElSUjogbnVtYmVyOyBcbiAgdW5sZXZlcmVkSVJSOiBudW1iZXI7IFxuICBpcnJCcmVha2Rvd246IElSUkJyZWFrZG93bltdIFxufSB7XG4gIFxuICBjb25zb2xlLmxvZygnSVJSIGNhbGN1bGF0aW9uIGlucHV0czonLCB7XG4gICAgcHVyY2hhc2VQcmljZSxcbiAgICBlcXVpdHksXG4gICAgbG9hbkFtb3VudCxcbiAgICBpbml0aWFsTk9JLFxuICAgIGluaXRpYWxEZWJ0U2VydmljZSxcbiAgICBhc3N1bXB0aW9uc1xuICB9KVxuICBcbiAgY29uc3QgYnJlYWtkb3duOiBJUlJCcmVha2Rvd25bXSA9IFtdXG4gIGxldCByZW1haW5pbmdEZWJ0ID0gbG9hbkFtb3VudFxuICBcbiAgICAgLy8gWWVhciAwOiBJbml0aWFsIGludmVzdG1lbnRcbiAgIGJyZWFrZG93bi5wdXNoKHtcbiAgICAgeWVhcjogMCxcbiAgICAgZ3Jvc3NJbmNvbWU6IDAsXG4gICAgIG9wZXJhdGluZ0V4cGVuc2VzOiAwLFxuICAgICBOT0k6IDAsXG4gICAgIGRlYnRTZXJ2aWNlOiAwLFxuICAgICBjYXNoRmxvd0JlZm9yZURlYnQ6IDAsXG4gICAgIGNhc2hGbG93QWZ0ZXJEZWJ0OiAtZXF1aXR5LFxuICAgICBjdW11bGF0aXZlQ2FzaEZsb3dCZWZvcmVEZWJ0OiAwLFxuICAgICBjdW11bGF0aXZlQ2FzaEZsb3dBZnRlckRlYnQ6IC1lcXVpdHksXG4gICAgIHJlbWFpbmluZ0RlYnQ6IGxvYW5BbW91bnQsXG4gICAgIHByb3BlcnR5VmFsdWU6IHB1cmNoYXNlUHJpY2UsXG4gICAgIGV4aXRFcXVpdHk6IDAsXG4gICAgIHRvdGFsUmV0dXJuVW5sZXZlcmVkOiAwLFxuICAgICB0b3RhbFJldHVybkxldmVyZWQ6IC1lcXVpdHksXG4gICAgIGFubnVhbENhc2hPbkNhc2g6IDBcbiAgIH0pXG4gIFxuICAvLyBZZWFycyAxIHRvIGFuYWx5c2lzVGVybTogT3BlcmF0aW5nIHBlcmlvZFxuICBmb3IgKGxldCB5ZWFyID0gMTsgeWVhciA8PSBhc3N1bXB0aW9ucy5hbmFseXNpc1Rlcm07IHllYXIrKykge1xuICAgICAgICAgLy8gQ2FsY3VsYXRlIGdyb3dpbmcgaW5jb21lIGFuZCBleHBlbnNlc1xuICAgICBjb25zdCByZW50R3Jvd3RoID0gTWF0aC5wb3coMSArIGFzc3VtcHRpb25zLnJlbnRHcm93dGhSYXRlLCB5ZWFyKVxuICAgICBjb25zdCBleHBlbnNlR3Jvd3RoID0gTWF0aC5wb3coMSArIGFzc3VtcHRpb25zLmV4cGVuc2VHcm93dGhSYXRlLCB5ZWFyKVxuICAgICBcbiAgICAgLy8gVXNlIHJlbnQgcm9sbCBkYXRhIGlmIGF2YWlsYWJsZSBmb3IgYWNjdXJhdGUgZ3Jvc3MgaW5jb21lXG4gICAgIGxldCB5ZWFyR3Jvc3NJbmNvbWU6IG51bWJlclxuICAgICBsZXQgeWVhck9wZXJhdGluZ0V4cGVuc2VzOiBudW1iZXJcbiAgICAgbGV0IHllYXJOT0k6IG51bWJlclxuICAgICBcbiAgICAgaWYgKHJlbnRSb2xsRGF0YSAmJiByZW50Um9sbERhdGEudG90YWxVbml0cyA+IDApIHtcbiAgICAgICAvLyBDYWxjdWxhdGUgZnJvbSBhY3R1YWwgcmVudCByb2xsIGRhdGFcbiAgICAgICBjb25zdCBiYXNlQW5udWFsUmVudCA9IHJlbnRSb2xsRGF0YS50b3RhbE1vbnRobHlSZW50ICogMTJcbiAgICAgICB5ZWFyR3Jvc3NJbmNvbWUgPSBiYXNlQW5udWFsUmVudCAqIHJlbnRHcm93dGhcbiAgICAgICB5ZWFyT3BlcmF0aW5nRXhwZW5zZXMgPSB5ZWFyR3Jvc3NJbmNvbWUgKiBhc3N1bXB0aW9ucy5leHBlbnNlUmF0aW9cbiAgICAgICB5ZWFyTk9JID0geWVhckdyb3NzSW5jb21lIC0geWVhck9wZXJhdGluZ0V4cGVuc2VzXG4gICAgIH0gZWxzZSB7XG4gICAgICAgLy8gRmFsbGJhY2sgdG8gTk9JLWJhc2VkIGNhbGN1bGF0aW9uXG4gICAgICAgeWVhck5PSSA9IGluaXRpYWxOT0kgKiByZW50R3Jvd3RoXG4gICAgICAgeWVhckdyb3NzSW5jb21lID0geWVhck5PSSAvICgxIC0gYXNzdW1wdGlvbnMuZXhwZW5zZVJhdGlvKVxuICAgICAgIHllYXJPcGVyYXRpbmdFeHBlbnNlcyA9IHllYXJHcm9zc0luY29tZSAtIHllYXJOT0lcbiAgICAgfVxuICAgIFxuICAgICAgICAgY29uc29sZS5sb2coYFllYXIgJHt5ZWFyfSBjYWxjdWxhdGlvbnM6YCwge1xuICAgICAgIHJlbnRHcm93dGg6IHJlbnRHcm93dGgudG9GaXhlZCg0KSxcbiAgICAgICB5ZWFyTk9JOiB5ZWFyTk9JLnRvRml4ZWQoMiksXG4gICAgICAgeWVhckdyb3NzSW5jb21lOiB5ZWFyR3Jvc3NJbmNvbWUudG9GaXhlZCgyKSxcbiAgICAgICB5ZWFyT3BlcmF0aW5nRXhwZW5zZXM6IHllYXJPcGVyYXRpbmdFeHBlbnNlcy50b0ZpeGVkKDIpXG4gICAgIH0pXG4gICAgXG4gICAgLy8gRGVidCBzZXJ2aWNlIHJlbWFpbnMgY29uc3RhbnQgKGZpeGVkLXJhdGUgbG9hbilcbiAgICBjb25zdCB5ZWFyRGVidFNlcnZpY2UgPSBpbml0aWFsRGVidFNlcnZpY2VcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgcmVtYWluaW5nIGRlYnQgKHNpbXBsaWZpZWQgLSBhc3N1bWVzIGxpbmVhciBhbW9ydGl6YXRpb24pXG4gICAgY29uc3QgYW5udWFsUHJpbmNpcGFsID0gbG9hbkFtb3VudCAvIGFzc3VtcHRpb25zLmFtb3J0aXphdGlvblllYXJzXG4gICAgcmVtYWluaW5nRGVidCA9IE1hdGgubWF4KDAsIHJlbWFpbmluZ0RlYnQgLSBhbm51YWxQcmluY2lwYWwpXG4gICAgXG4gICAgLy8gQ2FzaCBmbG93cyBiZWZvcmUgYW5kIGFmdGVyIGRlYnRcbiAgICBjb25zdCB5ZWFyQ2FzaEZsb3dCZWZvcmVEZWJ0ID0geWVhck5PSVxuICAgIGNvbnN0IHllYXJDYXNoRmxvd0FmdGVyRGVidCA9IHllYXJOT0kgLSB5ZWFyRGVidFNlcnZpY2VcbiAgICBcbiAgICAvLyBDdW11bGF0aXZlIGNhc2ggZmxvd3NcbiAgICBjb25zdCBjdW11bGF0aXZlQ2FzaEZsb3dCZWZvcmVEZWJ0ID0gYnJlYWtkb3duW3llYXIgLSAxXS5jdW11bGF0aXZlQ2FzaEZsb3dCZWZvcmVEZWJ0ICsgeWVhckNhc2hGbG93QmVmb3JlRGVidFxuICAgIGNvbnN0IGN1bXVsYXRpdmVDYXNoRmxvd0FmdGVyRGVidCA9IGJyZWFrZG93blt5ZWFyIC0gMV0uY3VtdWxhdGl2ZUNhc2hGbG93QWZ0ZXJEZWJ0ICsgeWVhckNhc2hGbG93QWZ0ZXJEZWJ0XG4gICAgXG4gICAgLy8gUHJvcGVydHkgdmFsdWUgZ3Jvd3RoICh1c2luZyBjYXAgcmF0ZSlcbiAgICBjb25zdCB5ZWFyUHJvcGVydHlWYWx1ZSA9IHllYXIgPT09IGFzc3VtcHRpb25zLmFuYWx5c2lzVGVybSA/IFxuICAgICAgKHllYXJOT0kgLyBhc3N1bXB0aW9ucy5leGl0Q2FwUmF0ZSkgOiAvLyBVc2UgZXhpdCBjYXAgcmF0ZSBmb3IgZmluYWwgeWVhclxuICAgICAgKHllYXJOT0kgLyBhc3N1bXB0aW9ucy5tYXJrZXRDYXBSYXRlKSAvLyBVc2UgbWFya2V0IGNhcCByYXRlIGZvciBpbnRlcm1lZGlhdGUgeWVhcnNcbiAgICBcbiAgICAvLyBFeGl0IGVxdWl0eSAod2hhdCB5b3UnZCBnZXQgaWYgeW91IHNvbGQpXG4gICAgY29uc3QgZXhpdEVxdWl0eSA9IHllYXIgPT09IGFzc3VtcHRpb25zLmFuYWx5c2lzVGVybSA/IHllYXJQcm9wZXJ0eVZhbHVlIC0gcmVtYWluaW5nRGVidCA6IDBcbiAgICBcbiAgICAvLyBUb3RhbCByZXR1cm4gdG8gZGF0ZSAobm90IHVzZWQgaW4gbmV3IHN0cnVjdHVyZSlcbiAgICAvLyBjb25zdCB0b3RhbFJldHVybiA9IGN1bXVsYXRpdmVDYXNoRmxvdyArIGV4aXRFcXVpdHlcbiAgICBcbiAgICAgICAgIC8vIENhbGN1bGF0ZSBhbm51YWwgY2FzaC1vbi1jYXNoIHJldHVybiAoWWVhciAxLTUgb25seSwgbm90IFllYXIgMClcbiAgICAgY29uc3QgYW5udWFsQ2FzaE9uQ2FzaCA9IHllYXIgPT09IDAgPyAwIDogeWVhckNhc2hGbG93QWZ0ZXJEZWJ0IC8gZXF1aXR5XG4gICAgIFxuICAgICBicmVha2Rvd24ucHVzaCh7XG4gICAgICAgeWVhcixcbiAgICAgICBncm9zc0luY29tZTogeWVhckdyb3NzSW5jb21lLFxuICAgICAgIG9wZXJhdGluZ0V4cGVuc2VzOiB5ZWFyT3BlcmF0aW5nRXhwZW5zZXMsXG4gICAgICAgTk9JOiB5ZWFyTk9JLFxuICAgICAgIGRlYnRTZXJ2aWNlOiB5ZWFyRGVidFNlcnZpY2UsXG4gICAgICAgY2FzaEZsb3dCZWZvcmVEZWJ0OiB5ZWFyQ2FzaEZsb3dCZWZvcmVEZWJ0LFxuICAgICAgIGNhc2hGbG93QWZ0ZXJEZWJ0OiB5ZWFyQ2FzaEZsb3dBZnRlckRlYnQsXG4gICAgICAgY3VtdWxhdGl2ZUNhc2hGbG93QmVmb3JlRGVidCxcbiAgICAgICBjdW11bGF0aXZlQ2FzaEZsb3dBZnRlckRlYnQsXG4gICAgICAgcmVtYWluaW5nRGVidCxcbiAgICAgICBwcm9wZXJ0eVZhbHVlOiB5ZWFyUHJvcGVydHlWYWx1ZSxcbiAgICAgICBleGl0RXF1aXR5LFxuICAgICAgIHRvdGFsUmV0dXJuVW5sZXZlcmVkOiBjdW11bGF0aXZlQ2FzaEZsb3dCZWZvcmVEZWJ0ICsgZXhpdEVxdWl0eSxcbiAgICAgICB0b3RhbFJldHVybkxldmVyZWQ6IGN1bXVsYXRpdmVDYXNoRmxvd0FmdGVyRGVidCArIGV4aXRFcXVpdHksXG4gICAgICAgYW5udWFsQ2FzaE9uQ2FzaFxuICAgICB9KVxuICB9XG4gIFxuICAvLyBDYWxjdWxhdGUgTGV2ZXJlZCBJUlIgKHdpdGggZGVidCkgLSBjYXNoIGZsb3dzIGFmdGVyIGRlYnQgc2VydmljZVxuICBjb25zdCBsZXZlcmVkQ2FzaEZsb3dzID0gYnJlYWtkb3duLm1hcChyb3cgPT4gcm93LmNhc2hGbG93QWZ0ZXJEZWJ0KVxuICBsZXZlcmVkQ2FzaEZsb3dzWzBdID0gLWVxdWl0eSAvLyBJbml0aWFsIGVxdWl0eSBpbnZlc3RtZW50IChuZWdhdGl2ZSlcbiAgbGV2ZXJlZENhc2hGbG93c1thc3N1bXB0aW9ucy5hbmFseXNpc1Rlcm1dICs9IChicmVha2Rvd25bYXNzdW1wdGlvbnMuYW5hbHlzaXNUZXJtXS5wcm9wZXJ0eVZhbHVlIC0gYnJlYWtkb3duW2Fzc3VtcHRpb25zLmFuYWx5c2lzVGVybV0ucmVtYWluaW5nRGVidCkgLy8gQWRkIG5ldCBzYWxlIHByb2NlZWRzIHRvIGZpbmFsIHllYXJcbiAgXG4gIGNvbnNvbGUubG9nKCdMZXZlcmVkIGNhc2ggZmxvd3MgZm9yIElSUiBjYWxjdWxhdGlvbjonLCBsZXZlcmVkQ2FzaEZsb3dzKVxuICBsZXQgbGV2ZXJlZElSUiA9IGNhbGN1bGF0ZUlSUihsZXZlcmVkQ2FzaEZsb3dzKVxuICBcbiAgLy8gVmFsaWRhdGUgbGV2ZXJlZCBJUlIgaXMgcmVhc29uYWJsZSAoYmV0d2VlbiAtNTAlIGFuZCArMjAwJSlcbiAgaWYgKGxldmVyZWRJUlIgPCAtMC41IHx8IGxldmVyZWRJUlIgPiAyLjApIHtcbiAgICBjb25zb2xlLmxvZygnTGV2ZXJlZCBJUlIgb3V0IG9mIHJlYXNvbmFibGUgcmFuZ2UsIHVzaW5nIGZhbGxiYWNrJylcbiAgICBsZXZlcmVkSVJSID0gY2FsY3VsYXRlU2ltcGxlSVJSKGxldmVyZWRDYXNoRmxvd3MsIGVxdWl0eSwgYXNzdW1wdGlvbnMuYW5hbHlzaXNUZXJtKVxuICB9XG4gIFxuICAvLyBDYWxjdWxhdGUgVW5sZXZlcmVkIElSUiAobm8gZGVidCkgLSBjYXNoIGZsb3dzIGJlZm9yZSBkZWJ0IHNlcnZpY2VcbiAgY29uc3QgdW5sZXZlcmVkQ2FzaEZsb3dzID0gYnJlYWtkb3duLm1hcChyb3cgPT4gcm93LmNhc2hGbG93QmVmb3JlRGVidClcbiAgdW5sZXZlcmVkQ2FzaEZsb3dzWzBdID0gLXB1cmNoYXNlUHJpY2UgLy8gSW5pdGlhbCBwcm9wZXJ0eSBpbnZlc3RtZW50IChuZWdhdGl2ZSlcbiAgdW5sZXZlcmVkQ2FzaEZsb3dzW2Fzc3VtcHRpb25zLmFuYWx5c2lzVGVybV0gKz0gYnJlYWtkb3duW2Fzc3VtcHRpb25zLmFuYWx5c2lzVGVybV0ucHJvcGVydHlWYWx1ZSAvLyBBZGQgZnVsbCBwcm9wZXJ0eSBzYWxlIHZhbHVlIHRvIGZpbmFsIHllYXJcbiAgXG4gIGNvbnNvbGUubG9nKCdVbmxldmVyZWQgY2FzaCBmbG93cyBmb3IgSVJSIGNhbGN1bGF0aW9uOicsIHVubGV2ZXJlZENhc2hGbG93cylcbiAgbGV0IHVubGV2ZXJlZElSUiA9IGNhbGN1bGF0ZUlSUih1bmxldmVyZWRDYXNoRmxvd3MpXG4gIFxuICAvLyBWYWxpZGF0ZSB1bmxldmVyZWQgSVJSIGlzIHJlYXNvbmFibGUgKGJldHdlZW4gLTUwJSBhbmQgKzIwMCUpXG4gIGlmICh1bmxldmVyZWRJUlIgPCAtMC41IHx8IHVubGV2ZXJlZElSUiA+IDIuMCkge1xuICAgIGNvbnNvbGUubG9nKCdVbmxldmVyZWQgSVJSIG91dCBvZiByZWFzb25hYmxlIHJhbmdlLCB1c2luZyBmYWxsYmFjaycpXG4gICAgdW5sZXZlcmVkSVJSID0gY2FsY3VsYXRlU2ltcGxlSVJSKHVubGV2ZXJlZENhc2hGbG93cywgcHVyY2hhc2VQcmljZSwgYXNzdW1wdGlvbnMuYW5hbHlzaXNUZXJtKVxuICB9XG4gIFxuICBjb25zb2xlLmxvZygnRmluYWwgdmFsaWRhdGVkIElSUnMgLSBMZXZlcmVkOicsIGxldmVyZWRJUlIsICdVbmxldmVyZWQ6JywgdW5sZXZlcmVkSVJSKVxuICBcbiAgcmV0dXJuIHsgbGV2ZXJlZElSUiwgdW5sZXZlcmVkSVJSLCBpcnJCcmVha2Rvd246IGJyZWFrZG93biB9XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUlSUihjYXNoRmxvd3M6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgLy8gTmV3dG9uLVJhcGhzb24gbWV0aG9kIGZvciBJUlIgY2FsY3VsYXRpb25cbiAgbGV0IGd1ZXNzID0gMC4xNSAvLyBTdGFydCB3aXRoIDE1JSBndWVzc1xuICBjb25zdCB0b2xlcmFuY2UgPSAwLjAwMDFcbiAgY29uc3QgbWF4SXRlcmF0aW9ucyA9IDEwMFxuICBcbiAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIElSUiBjYWxjdWxhdGlvbiB3aXRoIGNhc2ggZmxvd3M6JywgY2FzaEZsb3dzKVxuICBjb25zb2xlLmxvZygnSW5pdGlhbCBndWVzczonLCBndWVzcylcbiAgXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4SXRlcmF0aW9uczsgaSsrKSB7XG4gICAgY29uc3QgbnB2ID0gY2FsY3VsYXRlTlBWKGNhc2hGbG93cywgZ3Vlc3MpXG4gICAgY29uc3QgZGVyaXZhdGl2ZSA9IGNhbGN1bGF0ZU5QVkRlcml2YXRpdmUoY2FzaEZsb3dzLCBndWVzcylcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgSXRlcmF0aW9uICR7aSArIDF9OiBndWVzcz0ke2d1ZXNzLnRvRml4ZWQoNil9LCBucHY9JHtucHYudG9GaXhlZCgyKX0sIGRlcml2YXRpdmU9JHtkZXJpdmF0aXZlLnRvRml4ZWQoNil9YClcbiAgICBcbiAgICBpZiAoTWF0aC5hYnMoZGVyaXZhdGl2ZSkgPCAwLjAwMDEpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdEZXJpdmF0aXZlIHRvbyBzbWFsbCwgYnJlYWtpbmcnKVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgbmV3R3Vlc3MgPSBndWVzcyAtIG5wdiAvIGRlcml2YXRpdmVcbiAgICBcbiAgICAvLyBQcmV2ZW50IGV4dHJlbWUgdmFsdWVzXG4gICAgaWYgKG5ld0d1ZXNzIDwgLTAuOTkgfHwgbmV3R3Vlc3MgPiAxMCkge1xuICAgICAgY29uc29sZS5sb2coJ0d1ZXNzIG91dCBvZiByZWFzb25hYmxlIHJhbmdlLCB1c2luZyBmYWxsYmFjaycpXG4gICAgICByZXR1cm4gMC4xNSAvLyBGYWxsYmFjayB0byAxNSVcbiAgICB9XG4gICAgXG4gICAgaWYgKE1hdGguYWJzKG5ld0d1ZXNzIC0gZ3Vlc3MpIDwgdG9sZXJhbmNlKSB7XG4gICAgICBjb25zb2xlLmxvZygnQ29udmVyZ2VkIHRvIElSUjonLCBuZXdHdWVzcylcbiAgICAgIHJldHVybiBuZXdHdWVzc1xuICAgIH1cbiAgICBcbiAgICBndWVzcyA9IG5ld0d1ZXNzXG4gIH1cbiAgXG4gIGNvbnNvbGUubG9nKCdNYXggaXRlcmF0aW9ucyByZWFjaGVkLCByZXR1cm5pbmcgZ3Vlc3M6JywgZ3Vlc3MpXG4gIHJldHVybiBndWVzc1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVOUFYoY2FzaEZsb3dzOiBudW1iZXJbXSwgcmF0ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgbGV0IG5wdiA9IDBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYXNoRmxvd3MubGVuZ3RoOyBpKyspIHtcbiAgICBucHYgKz0gY2FzaEZsb3dzW2ldIC8gTWF0aC5wb3coMSArIHJhdGUsIGkpXG4gIH1cbiAgcmV0dXJuIG5wdlxufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVOUFZEZXJpdmF0aXZlKGNhc2hGbG93czogbnVtYmVyW10sIHJhdGU6IG51bWJlcik6IG51bWJlciB7XG4gIGxldCBkZXJpdmF0aXZlID0gMFxuICBmb3IgKGxldCBpID0gMTsgaSA8IGNhc2hGbG93cy5sZW5ndGg7IGkrKykge1xuICAgIGRlcml2YXRpdmUgLT0gKGkgKiBjYXNoRmxvd3NbaV0pIC8gTWF0aC5wb3coMSArIHJhdGUsIGkgKyAxKVxuICB9XG4gIHJldHVybiBkZXJpdmF0aXZlXG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNpbXBsZUlSUihjYXNoRmxvd3M6IG51bWJlcltdLCBlcXVpdHk6IG51bWJlciwgYW5hbHlzaXNUZXJtOiBudW1iZXIgPSA1KTogbnVtYmVyIHtcbiAgLy8gU2ltcGxlIElSUiBhcHByb3hpbWF0aW9uIGJhc2VkIG9uIHRvdGFsIHJldHVyblxuICBjb25zdCB0b3RhbENhc2hGbG93ID0gY2FzaEZsb3dzLnJlZHVjZSgoc3VtLCBjZikgPT4gc3VtICsgY2YsIDApXG4gIGNvbnN0IHRvdGFsUmV0dXJuID0gdG90YWxDYXNoRmxvdyArIGVxdWl0eVxuICBcbiAgaWYgKHRvdGFsUmV0dXJuIDw9IDApIHtcbiAgICByZXR1cm4gMC4wNSAvLyA1JSBpZiBubyBwb3NpdGl2ZSByZXR1cm5cbiAgfVxuICBcbiAgLy8gU2ltcGxlIGFwcHJveGltYXRpb246IGFzc3VtZSBhdmVyYWdlIHJldHVybiBvdmVyIGFuYWx5c2lzIHRlcm1cbiAgY29uc3QgYXZnQW5udWFsUmV0dXJuID0gdG90YWxSZXR1cm4gLyBhbmFseXNpc1Rlcm1cbiAgY29uc3Qgc2ltcGxlSVJSID0gYXZnQW5udWFsUmV0dXJuIC8gZXF1aXR5XG4gIFxuICAvLyBDYXAgYXQgcmVhc29uYWJsZSBsZXZlbHNcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHNpbXBsZUlSUiwgMC4wNSksIDAuMzApXG59XG4iXSwibmFtZXMiOlsiTmV4dFJlc3BvbnNlIiwicGRmIiwiT3BlbkFJIiwiWExTWCIsIlBhcGEiLCJvcGVuYWkiLCJhcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiT1BFTkFJX0FQSV9LRVkiLCJwYXJzZVJlbnRSb2xsRnJvbVVybCIsInVybCIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsIkVycm9yIiwic3RhdHVzVGV4dCIsImFycmF5QnVmZmVyIiwiYnVmZmVyIiwiQnVmZmVyIiwiZnJvbSIsImRhdGEiLCJpbmNsdWRlcyIsImNzdlRleHQiLCJ0b1N0cmluZyIsInJlc3VsdCIsInBhcnNlIiwiaGVhZGVyIiwic2tpcEVtcHR5TGluZXMiLCJ3b3JrYm9vayIsInJlYWQiLCJ0eXBlIiwic2hlZXROYW1lIiwiU2hlZXROYW1lcyIsIndvcmtzaGVldCIsIlNoZWV0cyIsInV0aWxzIiwic2hlZXRfdG9fanNvbiIsImNvbnNvbGUiLCJsb2ciLCJsZW5ndGgiLCJ0b3RhbFVuaXRzIiwib2NjdXBpZWRVbml0cyIsInZhY2FudFVuaXRzIiwidG90YWxNb250aGx5UmVudCIsInVuaXRzIiwic3VtbWFyeVJvdyIsInJvdyIsInJlbnRSb2xsQ29sIiwibWF4VW5pdHMiLCJ1bml0c1N0ciIsImlzTmFOIiwicGFyc2VGbG9hdCIsInBhcnNlSW50IiwidG90YWxVbml0c1N0ciIsInRvdGFsUmVudFN0ciIsIm9jY3VwYW5jeVN0ciIsIm9jY3VwYW5jeVBlcmNlbnQiLCJNYXRoIiwicm91bmQiLCJvY2N1cGFuY3lSYXRlIiwiYXZlcmFnZU1vbnRobHlSZW50IiwicmVudFJvbGxEYXRhIiwiZXJyb3IiLCJtZXNzYWdlIiwiREVGQVVMVF9BU1NVTVBUSU9OUyIsInZhY2FuY3kiLCJleHBlbnNlUmF0aW8iLCJtYXJrZXRDYXBSYXRlIiwibG9hblRvVmFsdWUiLCJpbnRlcmVzdFJhdGUiLCJhbW9ydGl6YXRpb25ZZWFycyIsInJlbnRHcm93dGhSYXRlIiwiZXhwZW5zZUdyb3d0aFJhdGUiLCJleGl0Q2FwUmF0ZSIsImFuYWx5c2lzVGVybSIsIlBPU1QiLCJyZXF1ZXN0IiwiYm9keSIsImpzb24iLCJvbUZpbGVVcmwiLCJyZW50Um9sbEZpbGVVcmwiLCJ1c2VyQXNzdW1wdGlvbnMiLCJzdGF0dXMiLCJwZGZSZXNwb25zZSIsInBkZkFycmF5QnVmZmVyIiwicGRmQnVmZmVyIiwicGRmRGF0YSIsImV4dHJhY3RlZFRleHQiLCJ0ZXh0IiwidHJpbSIsInBhcnNlZERhdGEiLCJhbmFseXplV2l0aE9wZW5BSSIsImhhc1JlbnRSb2xsRGF0YSIsInJlbnRSb2xsVW5pdHMiLCJyZW50Um9sbE1vbnRobHlSZW50IiwiZmluYWxBc3N1bXB0aW9ucyIsImRlZmF1bHRDYXBSYXRlIiwiZGVmYXVsdCIsInVzZXIiLCJmaW5hbCIsImRlYWxEYXRhIiwicGVyZm9ybVVuZGVyd3JpdGluZ0NhbGN1bGF0aW9ucyIsInByb21wdCIsImNvbXBsZXRpb24iLCJjaGF0IiwiY29tcGxldGlvbnMiLCJjcmVhdGUiLCJtb2RlbCIsIm1lc3NhZ2VzIiwicm9sZSIsImNvbnRlbnQiLCJ0ZW1wZXJhdHVyZSIsIm1heF90b2tlbnMiLCJyZXNwb25zZVRleHQiLCJjaG9pY2VzIiwianNvbk1hdGNoIiwibWF0Y2giLCJqc29uVGV4dCIsInJlcGxhY2UiLCJKU09OIiwiY2xlYW5FcnJvciIsInB1cmNoYXNlUHJpY2UiLCJ1bmRlZmluZWQiLCJ3aGlzcGVyUHJpY2UiLCJwcm9wZXJ0eV9uYW1lIiwicHJvcGVydHlOYW1lIiwiYXZnX3JlbnQiLCJhdmdSZW50IiwibWFya2V0X2NhcF9yYXRlIiwibWlzc2luZ0ZpZWxkcyIsInB1c2giLCJPYmplY3QiLCJrZXlzIiwiZXhwZWN0ZWRHUEkiLCJleHBlbnNlcyIsIk5PSSIsIndhcm4iLCJlbmhhbmNlZFBhcnNlZERhdGEiLCJwYXJzZUVycm9yIiwiYXNzdW1wdGlvbnMiLCJvY2N1cGFuY3kiLCJwYXJzZWRFeHBlbnNlcyIsInBhcnNlZE5PSSIsImZpbmFsVW5pdHMiLCJmaW5hbE9jY3VwYW5jeSIsImZpbmFsQXZnUmVudCIsInJlbnRSb2xsRGF0YURldGFpbHMiLCJvcmlnaW5hbFVuaXRzIiwib3JpZ2luYWxPY2N1cGFuY3kiLCJvcmlnaW5hbEF2Z1JlbnQiLCJncm9zc1BvdGVudGlhbEluY29tZSIsImVmZmVjdGl2ZUdyb3NzSW5jb21lIiwiZmluYWxOT0kiLCJhbm51YWxSZW50IiwidmFjYW5jeUxvc3MiLCJvcGVyYXRpbmdFeHBlbnNlcyIsInByaWNlRGlmZmVyZW5jZSIsImNhcFJhdGVWYWx1YXRpb24iLCJvcmlnaW5hbFBhcnNlZE5PSSIsImNhbGN1bGF0ZWRGaW5hbE5PSSIsImZpbmFsTk9JVXNlZCIsImNhbGN1bGF0ZWRQdXJjaGFzZVByaWNlIiwibG9hbkFtb3VudCIsImVxdWl0eSIsIm1vbnRobHlSYXRlIiwidG90YWxQYXltZW50cyIsImRlYnRTZXJ2aWNlIiwicG93IiwiYW5udWFsRGVidFNlcnZpY2UiLCJEU0NSIiwiY2FzaE9uQ2FzaFJldHVybiIsImxldmVyZWRJUlIiLCJ1bmxldmVyZWRJUlIiLCJpcnJCcmVha2Rvd24iLCJjYWxjdWxhdGVEZXRhaWxlZElSUiIsImZvckVhY2giLCJ5ZWFyIiwiY2FzaEZsb3dCZWZvcmVEZWJ0IiwiY2FzaEZsb3dBZnRlckRlYnQiLCJjdW11bGF0aXZlQ2FzaEZsb3dCZWZvcmVEZWJ0IiwiY3VtdWxhdGl2ZUNhc2hGbG93QWZ0ZXJEZWJ0IiwicmVtYWluaW5nRGVidCIsInByb3BlcnR5VmFsdWUiLCJleGl0RXF1aXR5IiwiZmluYWxEZWFsRGF0YSIsImluaXRpYWxOT0kiLCJpbml0aWFsRGVidFNlcnZpY2UiLCJicmVha2Rvd24iLCJncm9zc0luY29tZSIsInRvdGFsUmV0dXJuVW5sZXZlcmVkIiwidG90YWxSZXR1cm5MZXZlcmVkIiwiYW5udWFsQ2FzaE9uQ2FzaCIsInJlbnRHcm93dGgiLCJleHBlbnNlR3Jvd3RoIiwieWVhckdyb3NzSW5jb21lIiwieWVhck9wZXJhdGluZ0V4cGVuc2VzIiwieWVhck5PSSIsImJhc2VBbm51YWxSZW50IiwidG9GaXhlZCIsInllYXJEZWJ0U2VydmljZSIsImFubnVhbFByaW5jaXBhbCIsIm1heCIsInllYXJDYXNoRmxvd0JlZm9yZURlYnQiLCJ5ZWFyQ2FzaEZsb3dBZnRlckRlYnQiLCJ5ZWFyUHJvcGVydHlWYWx1ZSIsImxldmVyZWRDYXNoRmxvd3MiLCJtYXAiLCJjYWxjdWxhdGVJUlIiLCJjYWxjdWxhdGVTaW1wbGVJUlIiLCJ1bmxldmVyZWRDYXNoRmxvd3MiLCJjYXNoRmxvd3MiLCJndWVzcyIsInRvbGVyYW5jZSIsIm1heEl0ZXJhdGlvbnMiLCJpIiwibnB2IiwiY2FsY3VsYXRlTlBWIiwiZGVyaXZhdGl2ZSIsImNhbGN1bGF0ZU5QVkRlcml2YXRpdmUiLCJhYnMiLCJuZXdHdWVzcyIsInJhdGUiLCJ0b3RhbENhc2hGbG93IiwicmVkdWNlIiwic3VtIiwiY2YiLCJ0b3RhbFJldHVybiIsImF2Z0FubnVhbFJldHVybiIsInNpbXBsZUlSUiIsIm1pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./app/api/parseOM/route.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/formdata-node","vendor-chunks/openai","vendor-chunks/form-data-encoder","vendor-chunks/whatwg-url","vendor-chunks/agentkeepalive","vendor-chunks/tr46","vendor-chunks/xlsx","vendor-chunks/web-streams-polyfill","vendor-chunks/node-fetch","vendor-chunks/webidl-conversions","vendor-chunks/papaparse","vendor-chunks/ms","vendor-chunks/humanize-ms","vendor-chunks/event-target-shim","vendor-chunks/abort-controller"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2FparseOM%2Froute&page=%2Fapi%2FparseOM%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2FparseOM%2Froute.ts&appDir=C%3A%5CUsers%5Cwesto%5COneDrive%5CDocuments%5CFirst%20Pass%20OM%20Reader%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cwesto%5COneDrive%5CDocuments%5CFirst%20Pass%20OM%20Reader&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();